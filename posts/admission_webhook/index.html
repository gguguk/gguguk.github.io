<!DOCTYPE html><html lang="en" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Expires" content="0"><meta http-equiv="Pragma" content="no-cache"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook" /><meta name="author" content="Gukwon Koo" /><meta property="og:locale" content="en" /><meta name="description" content="IRSA(IAM Role for Service Account)는 AWS EKS에서 파드 단위로 권한을 관리하기 위한 방법 또는 프로세스입니다. 요즘에 회사에서 kubeflow를 셋팅하고 있는데 AWS의 특정 리소스(S3 등)와의 통신을 위해 파드에 일정 권한을 부여해야할 상황이 자주 발생합니다. 저는 이때 주로 IRSA를 활용하여 업무를 진행하고 있습니다. IRSA를 활용하면 권한 관리가 매우 수월하고, 보안과 관련된 사항이 노출될 위험도가 낮기 때문입니다. IRSA의 대안으로 Secret을 활용할 수 있습니다. 그러나 Secret은 namespaced resource 이므로 작업성이 더 떨어진다고 느껴져서 그다지 선호하지 않습니다(하지만 직관적인 방법인 것은 사실입니다)." /><meta property="og:description" content="IRSA(IAM Role for Service Account)는 AWS EKS에서 파드 단위로 권한을 관리하기 위한 방법 또는 프로세스입니다. 요즘에 회사에서 kubeflow를 셋팅하고 있는데 AWS의 특정 리소스(S3 등)와의 통신을 위해 파드에 일정 권한을 부여해야할 상황이 자주 발생합니다. 저는 이때 주로 IRSA를 활용하여 업무를 진행하고 있습니다. IRSA를 활용하면 권한 관리가 매우 수월하고, 보안과 관련된 사항이 노출될 위험도가 낮기 때문입니다. IRSA의 대안으로 Secret을 활용할 수 있습니다. 그러나 Secret은 namespaced resource 이므로 작업성이 더 떨어진다고 느껴져서 그다지 선호하지 않습니다(하지만 직관적인 방법인 것은 사실입니다)." /><link rel="canonical" href="https://gguguk.github.io/posts/admission_webhook/" /><meta property="og:url" content="https://gguguk.github.io/posts/admission_webhook/" /><meta property="og:site_name" content="생각과 고민." /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-13T23:25:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Gukwon Koo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Gukwon Koo"},"dateModified":"2022-09-22T20:56:50+09:00","datePublished":"2022-09-13T23:25:00+09:00","description":"IRSA(IAM Role for Service Account)는 AWS EKS에서 파드 단위로 권한을 관리하기 위한 방법 또는 프로세스입니다. 요즘에 회사에서 kubeflow를 셋팅하고 있는데 AWS의 특정 리소스(S3 등)와의 통신을 위해 파드에 일정 권한을 부여해야할 상황이 자주 발생합니다. 저는 이때 주로 IRSA를 활용하여 업무를 진행하고 있습니다. IRSA를 활용하면 권한 관리가 매우 수월하고, 보안과 관련된 사항이 노출될 위험도가 낮기 때문입니다. IRSA의 대안으로 Secret을 활용할 수 있습니다. 그러나 Secret은 namespaced resource 이므로 작업성이 더 떨어진다고 느껴져서 그다지 선호하지 않습니다(하지만 직관적인 방법인 것은 사실입니다).","headline":"IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook","mainEntityOfPage":{"@type":"WebPage","@id":"https://gguguk.github.io/posts/admission_webhook/"},"url":"https://gguguk.github.io/posts/admission_webhook/"}</script><title>IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook | 생각과 고민.</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="생각과 고민."><meta name="application-name" content="생각과 고민."><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/sample/bear.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">생각과 고민.</a></div><div class="site-subtitle font-italic">주니어 데이터 사이언티스트입니다.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/gguguk" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/%EA%B5%AD%EC%9B%90-%EA%B5%AC-32a9691a1/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Gukwon Koo </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Sep 13, 2022, 11:25 PM +0900" >Sep 13, 2022<i class="unloaded">2022-09-13T23:25:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Sep 22, 2022, 8:56 PM +0900" >Sep 22, 2022<i class="unloaded">2022-09-22T20:56:50+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3287 words">18 min read</span></div></div><div class="post-content"><p>IRSA(IAM Role for Service Account)는 AWS EKS에서 파드 단위로 권한을 관리하기 위한 방법 또는 프로세스입니다. 요즘에 회사에서 kubeflow를 셋팅하고 있는데 AWS의 특정 리소스(S3 등)와의 통신을 위해 파드에 일정 권한을 부여해야할 상황이 자주 발생합니다. 저는 이때 주로 IRSA를 활용하여 업무를 진행하고 있습니다. IRSA를 활용하면 권한 관리가 매우 수월하고, 보안과 관련된 사항이 노출될 위험도가 낮기 때문입니다. IRSA의 대안으로 <code class="language-plaintext highlighter-rouge">Secret</code>을 활용할 수 있습니다. 그러나 <code class="language-plaintext highlighter-rouge">Secret</code>은 <a href="https://stackoverflow.com/q/46297949">namespaced resource 이므로</a> 작업성이 더 떨어진다고 느껴져서 그다지 선호하지 않습니다(하지만 직관적인 방법인 것은 사실입니다).</p><p>IRSA를 활용하는 것 자체는 그다지 어려운 일은 아닙니다. AWS IAM의 체계와 쿠버네티스 기본 개념만 있다면 손쉽게 적용할 수 있습니다. 그러나 IRSA의 동작 방식을 이해하기 위해서는 많은 배경지식이 필요합니다. 이 시리즈를 시작한 목적도 제가 현업에서 IRSA의 동작 과정상 필요한 배경지식을 제대로 파악하지 못 하고 단순 활용만 하고 있었기에 제대로 된 정리가 필요하다는 생각이 들어서였습니다.</p><p>그래서 준비 했습니다. <em>IRSA의 원리를 파헤쳐보자</em> 시리즈! 앞으로 IRSA의 작동 원리를 완벽하게 이해하기 위해서 필요한 요소들을 정리하고자 합니다. 그 첫번째 순서로 쿠버네티스 admission webhook을 다뤄보겠습니다. admission webhook은 IRSA가 이루어지기 위한 쿠버네티스쪽의 필수 오브젝트입니다.</p><p><br /></p><h1 id="admission-controller란">Admission Controller란?</h1><h3 id="admission-controller">Admission Controller</h3><p><img data-proofer-ignore data-src="https://www.oreilly.com/library/view/kubernetes-best-practices/9781492056461/assets/kubp_1701.png" alt="https://kubernetes.io/blog/2019/03/21/a-guide-to-kubernetes-admission-controllers/" /><em>admission control(출처: <a href="https://www.digihunch.com/2022/01/kubernetes-admission-control/">Kubernetes Admission Control</a>)</em></p><p><strong>admission controller</strong>란 kubernetes api server를 호출 했을 때, 요청 내용을 가로채서(intercept) 변형(mutating)하거나 검증(validating)하는 쿠버네티스 plugin의 집합을 가르킵니다. admission controller가 개입하여 무엇인가 하는 것을 admission control이라고도 표현할 수 있겠습니다. 앞서 언급 했지만 admission control은 크게 2단계로서 변형(mutating), 검증(validating) 단계가 있습니다. 모든 단계를 성공적으로 통과한 요청은 <code class="language-plaintext highlighter-rouge">etcd</code>에 저장(persistence) 됩니다.</p><p><br /></p><p>변형(mutating)은 요청 내용을 수정하는 것을 말합니다. 예를 들어 특정 조건을 만족시킬 때 환경 변수를 추가적으로 주입시키는 등의 행위를 할 수 있습니다. 검증(validating)은 해당 요청 내용이 실제 쿠버네티스 클러스터에 적용되어도 되는지 확인합니다. 만약 부적절한 요청일 경우 거절 될 수 있습니다. 예를 들어서 특정 네임스페이스가 차지할 수 있는 리소스의 총량을 초과한다면 해당 요청은 거절 될 수 있습니다. 너무 추상적인 개념 위주로만 설명하니 별로 와 닿지 않네요. 구체적인 사례를 들어 볼까요? 여러분이 아실만한 <a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do">admission controller</a>에는 다음과 같은 것들이 있습니다.</p><ul><li><a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#limitranger">LimitRange</a>, <a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#resourcequota">ResourceQuota</a>: 특정 네임스페이스의 자원의 한계치를 컨트롤 합니다.<li><a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#serviceaccount">ServiceAccount</a>: 자주 사용하던 ServiceAccount도 admission controller의 한 종류입니다. ServiceAccount에 대한 자동화(automation)가 구현되어 있습니다.<li><a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#namespacelifecycle">NamespaceLifecycle</a>: <code class="language-plaintext highlighter-rouge">Terminating</code> 단계에 있는 namespace에 object가 배포되는 것을 거절(deny) 합니다.</ul><p><br /></p><p>이러한 admission controller는 쿠버네티스 클러스터를 생성하면 기본적으로 kube-apiserver에 binary 형태로 컴파일 되어 존재합니다. 만일 새로운 admission controller을 만들었고 이를 쿠버네티스 클러스터에 적용하고 싶다면, 이를 binary로 컴파일해서 kube-apiserver에 적용해야 합니다. 이러한 작업이 자주 발생한다면 어떨까요? 컴파일을 반복적으로 수행해야 하기 때문에 번거롭고 유연성이 떨어질 것입니다. 이와 같은 불편함을 해결하고자 <strong>admission webhook</strong>이라는 개념이 등장하게 되었습니다.</p><p><br /></p><h3 id="admission-webhooks">Admission Webhooks</h3><p><img data-proofer-ignore data-src="https://miro.medium.com/max/4800/0*H5j2uU_zFUEU__Uz.jpg" alt="" /><em>admission webhook (출처: <a href="https://medium.com/ibm-cloud/diving-into-kubernetes-mutatingadmissionwebhook-6ef3c5695f74">Diving into Kubernetes MutatingAdmissionWebhook</a>)</em></p><p>admission webhooks이란 요청 내용을 변형(mutating)하는 <code class="language-plaintext highlighter-rouge">mutating webhook</code>과 검증(validating)하는 <code class="language-plaintext highlighter-rouge">validating webhook</code>을 통칭하는 개념입니다(admission webhook은 쿠버네티스 1.9 버전부터 등장했습니다).</p><blockquote><p><strong>webhook</strong>이라는 단어가 여기저기 등장해서 개념이 혼용될 수 있는데, <code class="language-plaintext highlighter-rouge">kube-apiserver</code>에서 mutating admission을 담당하는 admission controller인 <code class="language-plaintext highlighter-rouge">MutatingAdmissionWebhook</code>과 admission webhook의 한 종류인 <code class="language-plaintext highlighter-rouge">mutating webhook</code>은 서로 다른 개념이라는 것을 꼭 인지해야합니다. <code class="language-plaintext highlighter-rouge">MutatingAdmissionWebhook</code>은 admission control 상의 하나의 과정 혹은 단계(phase)이며, <code class="language-plaintext highlighter-rouge">mutating webhook</code>은 실제로 요청 내용을 변형하거나 검증하는 주체입니다. 이는 validating에서도 동일하게 적용됩니다.</p></blockquote><p><br /></p><p><a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#what-are-admission-webhooks">공식 문서</a>에서는 admission webhooks(mutating webhook 및 validating webhook)을 admission request를 받아서 특정 행위를 수행하는 HTTP callback이라고 표현합니다.</p><blockquote><p>여기서 말하는 callback은 <a href="https://satisfactoryplace.tistory.com/18">특정 이벤트에 따라 호출되어지는 함수</a>라고 생각하는게 이해하기 쉽습니다.</p></blockquote><p>admission webhook은 흔히 생각할 수 있는 API 서버의 형태로 구현됩니다. 따라서 admission webhook을 좀 더 구체적으로 표현하기 위해 (admission) webhook <strong>sever</strong>라고 표현하기도 합니다(위 그림에서는 webhook sever로 표현되어 있습니다). 일반적인 admission controller는 유연성이 떨어진다고 언급하였는데요. admission webhooks는 어떤 방식으로 동작하기에 이런 한계를 극복할 수 있었을까요?</p><p><br /></p><p>어떤 요청이 kube-apiserver에 도착하면 인증 및 인가를 거친 후 여러가지 admission controller를 통과하며 그 요청 내용이 변화하게 됩니다. 그러다가 MutatingAdmissionWebhook에 단계에 도착하면 쿠버네티스는 MutatingWebhookConfiguration을 살펴보면서 해당 요청이 여기에 적힌 조건에 부합하는지를 판단합니다. 만일 특정 조건에 부합한다면 이를 처리할 수 있는, <code class="language-plaintext highlighter-rouge">kube-apiserver</code> 밖에 존재하는 mutating webhook (sever)로 해당 요청을 보냅니다. 이 때 <code class="language-plaintext highlighter-rouge">admissionReview</code>라는 데이터를 POST 방식으로 body에 실어서 보냅니다. mutating webhook에는 해당 데이터를 처리하는 로직이 구현되어 있고 그 결과를 응답으로 돌려 줍니다.</p><p><br /></p><p>정리하자면 쿠버네티스는 admission webhook이라는 새로운 개념을 통해서 admission control 로직을 외부의 API, 즉 admission webhook (sever)에 맡길 수 있게 되었습니다. 따라서 새로운 admission control 로직을 적용하고자 할 때 kube-apisever에 존재하는 admission controller들처럼 컴파일 과정을 거칠 필요가 없습니다. 그저 어떤 조건을 만족할 때 어느 API로 보낼지를 결정하고(<code class="language-plaintext highlighter-rouge">MutatingWebhookConfiguration</code>), admission webhook (server)를 새로 배포하기만 하면 됩니다. 그렇기 때문에 일반적인 admission controller 보다 유연성이 높다라고 할 수 있습니다. admission webhook은 다음과 같은 것들이 있습니다.</p><ul><li>Istio Envoy Sidecar: 파드 생성 요청이 오면 해당 파드에 Envoy Sidecar 컨테이너를 강제로 주입합니다.<li><code class="language-plaintext highlighter-rouge">StorageClass</code> 프로비저닝: PVC가 생성되는 것을 지켜보다가 자동으로 PVC에 미리 선언된 StorageClass를 주입합니다.<li>pod-identity-webhook: EKS를 생성하면 control plane에 자동으로 생성되는 admission webhook입니다. serviceAccount에 iam arn이 선언되어 있으면 pod의 스펙을 변형합니다.</ul><p><br /></p><p>admission webhook의 구현과 관련된 자세한 사항은 본 글의 범위를 벗어나므로 자세한 사항은 <a href="https://coffeewhale.com/kubernetes/admission-control/2021/04/28/opa1/">링크1</a>, <a href="https://medium.com/ibm-cloud/diving-into-kubernetes-mutatingadmissionwebhook-6ef3c5695f74">링크2</a> 등의 글을 참고해주세요.</p><blockquote><p>본 글의 주제와 크게 관련이 없어 설명하진 않았지만 admission webhook이 작동하기 전에 <code class="language-plaintext highlighter-rouge">kube-apiserver</code>를 호출한 개체가 승인된 개체인지 인증(authentication)하는 과정과 그 개체가 특정 행위를 수행할 수 있는 권한이 있는지 인가(authorization)하는 과정이 먼저 선행됩니다.</p></blockquote><p><br /></p><h1 id="admission-webhook-예시-pod-identity-webhook">Admission Webhook 예시: Pod Identity Webhook</h1><p>EKS 클러스터를 셋팅하면 기본적으로 pod-identity-webhook(<code class="language-plaintext highlighter-rouge">mutating webhook</code>)이 생성됩니다. 그러나 해당 webhook은 EKS가 관리하는 control plane에 존재하기 때문에 일반적인 방법으로는 해당 admission webhook을 직접 보긴 어렵습니다. 그래도 우리는 간접적으로 그 존재를 알 수 있는데, 클러스터에 생성된 pod-identity-webhook <code class="language-plaintext highlighter-rouge">MutatingWebhookConfiguration</code> 오브젝트를 찾을 수 있습니다.</p><div class="language-yaml highlighter-rouge"><div class="code-header" text-data="yaml"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="nn">...</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">MutatingWebhookConfiguration</span>
<span class="na">webhooks</span><span class="pi">:</span>
  <span class="na">clientConfig</span><span class="pi">:</span>
    <span class="na">url</span><span class="pi">:</span> <span class="s">https://127.0.0.1:23443/mutate</span>
  <span class="na">rules</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">apiGroups</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s2">"</span><span class="s">"</span>
    <span class="na">apiVersions</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">v1</span>
    <span class="na">operations</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">CREATE</span>
    <span class="na">resources</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">pods</span>
    <span class="na">scope</span><span class="pi">:</span> <span class="s1">'</span><span class="s">*'</span>
</pre></table></code></div></div><p>해당 매니패스트를 간단하게 살펴보면 다음과 같은 규칙이 적혀 있습니다:</p><ul><li><code class="language-plaintext highlighter-rouge">kube-apiserver</code>에 pod를 생성하는 요청이 들어왔을 때,<li>https://127.0.0.1:23443/mutate 주소를 가진 mutating webhook server로 보냅니다(아마 pod-identity-webhook의 주소라고 생각됩니다).</ul><p><br /></p><p>해당 mutating webhook server는 파드의 <code class="language-plaintext highlighter-rouge">ServiceAccount</code>에 <code class="language-plaintext highlighter-rouge">metadata.annotations.eks.amazonaws.com/role-arn</code>가 선언되어 있는 요청일 경우, IRSA를 위한 환경 변수를 설정하거나 projected volume을 설정하는 요청으로 변환합니다. 즉 요청의 변형(mutating)이 일어나는 것이죠. 아래의 매니패스트를 클러스터에 배포해서 pod-identity-webhook의 개입(intercept) 결과를 확인 해보도록 하죠. iam role arn이 명시된 <code class="language-plaintext highlighter-rouge">ServiceAccount</code>와 그 <code class="language-plaintext highlighter-rouge">ServiceAccount</code>를 활용하는 파드를 생성하는 간단한 매니패스트입니다.</p><div class="language-yaml highlighter-rouge"><div class="code-header" text-data="yaml"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ServiceAccount</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">annotations</span><span class="pi">:</span>
    <span class="na">eks.amazonaws.com/role-arn</span><span class="pi">:</span> <span class="s">arn:aws:iam::1234567890:role/mutating-webhook-tutorial-role</span>  <span class="c1"># 적절한 값으로 수정 필요</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">mutating-webhook-tutorial-sa</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
<span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">mutating-webhook-tutorial-pod</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">serviceAccount</span><span class="pi">:</span> <span class="s">mutating-webhook-tutorial-sa</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">mutating-webhook-tutorial</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">busybox</span>
    <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s1">'</span><span class="s">sh'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">-c'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">echo</span><span class="nv"> </span><span class="s">Mutating</span><span class="nv"> </span><span class="s">Webhook</span><span class="nv"> </span><span class="s">Tutorial!!</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">3600'</span><span class="pi">]</span>
</pre></table></code></div></div><p><br /></p><p>위 매니패스트를 작성하고 쿠버네티스에 배포하면 <code class="language-plaintext highlighter-rouge">Pod</code>에 다음과 같은 값들이 추가적으로 설정되어 있음을 알 수 있습니다.</p><ul><li>env[*].name<li>env[*].value<li>volumeMounts<li>volumes</ul><div class="language-yaml highlighter-rouge"><div class="code-header" text-data="yaml"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="s">...</span>
    <span class="s">env</span><span class="err">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">AWS_DEFAULT_REGION</span>
      <span class="na">value</span><span class="pi">:</span> <span class="s">ap-northeast-2</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">AWS_REGION</span>
      <span class="na">value</span><span class="pi">:</span> <span class="s">ap-northeast-2</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">AWS_ROLE_ARN</span>
      <span class="na">value</span><span class="pi">:</span> <span class="s">arn:aws:iam::1234567890:role/mutating-webhook-tutorial-role</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">AWS_WEB_IDENTITY_TOKEN_FILE</span>
      <span class="na">value</span><span class="pi">:</span> <span class="s">/var/run/secrets/eks.amazonaws.com/serviceaccount/token</span>
  <span class="s">...</span>
    <span class="s">volumeMounts</span><span class="err">:</span>
    <span class="pi">-</span> <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/var/run/secrets/eks.amazonaws.com/serviceaccount</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">aws-iam-token</span>
  <span class="s">...</span>
  <span class="s">volumes</span><span class="err">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">aws-iam-token</span>
    <span class="na">projected</span><span class="pi">:</span>
      <span class="na">defaultMode</span><span class="pi">:</span> <span class="m">420</span>
      <span class="na">sources</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">serviceAccountToken</span><span class="pi">:</span>
          <span class="na">audience</span><span class="pi">:</span> <span class="s">sts.amazonaws.com</span>
          <span class="na">expirationSeconds</span><span class="pi">:</span> <span class="m">86400</span>
          <span class="na">path</span><span class="pi">:</span> <span class="s">token</span>
</pre></table></code></div></div><p>분명히 매니패스트를 배포할 당시에는 이와 같은 환경 변수를 어디에도 설정하지 않았습니다. 그렇데 어떻게 실제 배포된 파드에 저런 환경 변수들이 셋팅되어 있을까요? 이는 admission webhook(구체적으로는 mutating webhook)인 pod-identity-webhook가 요청 내용을 가로채서 파드의 환경 변수에 <code class="language-plaintext highlighter-rouge">AWS_DEFAULT_REGION</code>, <code class="language-plaintext highlighter-rouge">AWS_REGION</code>, <code class="language-plaintext highlighter-rouge">AWS_ROLE_ARN</code>, <code class="language-plaintext highlighter-rouge">AWS_WEB_IDENTITY_TOKEN_FILE</code>를 생성하고, <code class="language-plaintext highlighter-rouge">serviceAccountToken</code>을 파드에 볼륨 마운트하는 내용으로 변형(mutating) 했기 때문입니다. 물론 검증(validating) 단계도 정상적으로 통과 했기 때문에 해당 요청 내용은 <code class="language-plaintext highlighter-rouge">etcd</code>에 적재 되었을 것입니다. 이와 관련된 좀 더 자세한 내용은 <a href="https://github.com/aws/amazon-eks-pod-identity-webhook#eks-walkthrough">링크</a>를 참조해 보시면 좋을 듯 합니다.</p><p><br /></p><h1 id="마무리">마무리</h1><p>간단하게 admission controller를 살펴보았고, 그들의 한계점을 살펴보았습니다. 그리고 그 한계점을 극복하기 위한 새로운 개념인 admission webhooks도 살펴보았습다. <code class="language-plaintext highlighter-rouge">kube-apiserver</code>에 보내지는 요청 내용을 중간에서 변형(mutating) 하거나 검증(validating) 할 수 있으므로 안 그래도 자유로운 쿠버네티스에 더 유연성을 더해줄 수 있는 컴포넌트라는 생각이 듭니다. 그러나 아직 우리는 pod-identity-webhook이 요청을 변형한 결과의 의미를 명확하게 살펴보지 않았습니다. 그러나 마운트 되는 환경 변수를 자세히 보면 뭔가 AWS IAM과 관련된, 즉 권한 관리와 밀접하게 관련되어 있다는 사실을 짐작할 수는 있겠습니다. 앞으로 IRSA 시리즈 글에서 더 구체화 시켜 보시죠.</p><p><br /></p><h1 id="참고자료">참고자료</h1><ul><li><a href="https://kubernetes.io/blog/2019/03/21/a-guide-to-kubernetes-admission-controllers/#what-are-kubernetes-admission-controllers">What are Kubernetes admission controllers?</a><li><a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">Dynamic Admission Control</a><li>[<a href="https://leffept.tistory.com/329">Webhook] 웹훅이란?</a><li><a href="https://coffeewhale.com/kubernetes/admission-control/2021/04/28/opa1/">쿠버네티스 Admission Control #1</a><li><a href="https://tech.devsisters.com/posts/pod-iam-role/">EKS에서 쿠버네티스 포드의 IAM 권한 제어하기: Pod Identity Webhook</a><li><a href="https://satisfactoryplace.tistory.com/18">콜백 함수(Callback)의 정확한 의미는 무엇일까?</a><li><a href="https://medium.com/ibm-cloud/diving-into-kubernetes-mutatingadmissionwebhook-6ef3c5695f74">Diving into Kubernetes MutatingAdmissionWebhook</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/mlops/'>MLOps</a>, <a href='/categories/kubernetes/'>Kubernetes</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/kubernetes/" class="post-tag no-text-decoration" >kubernetes</a> <a href="/tags/k8s/" class="post-tag no-text-decoration" >k8s</a> <a href="/tags/admission-controller/" class="post-tag no-text-decoration" >admission controller</a> <a href="/tags/admission-webhook/" class="post-tag no-text-decoration" >admission webhook</a> <a href="/tags/pod-identity-webhook/" class="post-tag no-text-decoration" >pod identity webhook</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook - 생각과 고민.&url=https://gguguk.github.io/posts/admission_webhook/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook - 생각과 고민.&u=https://gguguk.github.io/posts/admission_webhook/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook - 생각과 고민.&url=https://gguguk.github.io/posts/admission_webhook/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/tsne/">T-SNE 이해하기</a><li><a href="/posts/how_to_work_python/">CS50 - 파이썬이 소스 코드를 실행하는 과정과 원리</a><li><a href="/posts/OIDC/">IRSA의 원리를 파헤쳐보자 4 - OIDC</a><li><a href="/posts/OAuth/">IRSA의 원리를 파헤쳐보자 3 - OAuth2.0</a><li><a href="/posts/admission_webhook/">IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/service_account_volume_projection/"><div class="card-body"> <span class="timeago small" >Oct 26, 2022<i class="unloaded">2022-10-26T22:12:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>IRSA의 원리를 파헤쳐보자 2 - K8S Sevice Account와 Service Account Token Volume Projection</h3><div class="text-muted small"><p> IRSA의 원리를 파헤쳐보자 시리즈의 마지막 글입니다. 저번 글에서는 admission webhook을 학습했습니다. 요약하자면 EKS 클러스터를 설치하면 control plane에 pod identity webhook이라는 webhook server(일종의 API 서버)가 함께 배포되고, pod identity webhook은 서비스 어카운트에 ia...</p></div></div></a></div><div class="card"> <a href="/posts/OAuth/"><div class="card-body"> <span class="timeago small" >Nov 26, 2022<i class="unloaded">2022-11-26T20:04:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>IRSA의 원리를 파헤쳐보자 3 - OAuth2.0</h3><div class="text-muted small"><p> IRSA의 원리를 파헤쳐보자 시리즈의 세번째 글입니다. 지난 시간에는 service account token volume projection에 대해서 살펴보았습니다. 핵심은 projected service account token은 기본 service account token과 다르게 audience나 만료기간 등의 추가적인 정보를 삽입할 수 있으며 ...</p></div></div></a></div><div class="card"> <a href="/posts/OIDC/"><div class="card-body"> <span class="timeago small" >Dec 20, 2022<i class="unloaded">2022-12-20T21:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>IRSA의 원리를 파헤쳐보자 4 - OIDC</h3><div class="text-muted small"><p> 지난 글에서는 OAuth2.0를 살펴보았습니다. OAuth2.0을 이해해야 본 글에서 설명할 OIDC를 이해할 수 있습니다. OIDC는 인증(authentication)을 위한 프로토콜입니다. IRSA의 원리를 파헤쳐보자 시리즈 IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook IRSA의 원리를 파헤쳐보자 2 - ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/https_ssl_tls/" class="btn btn-outline-primary" prompt="Older"><p>HTTPS의 동작 원리와 그 구성 요소들</p></a> <a href="/posts/service_account_volume_projection/" class="btn btn-outline-primary" prompt="Newer"><p>IRSA의 원리를 파헤쳐보자 2 - K8S Sevice Account와 Service Account Token Volume Projection</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/gguguk">Gukwon Koo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/retrospective/">retrospective</a> <a class="post-tag" href="/tags/k8s/">k8s</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/nlp/">nlp</a> <a class="post-tag" href="/tags/statistics/">statistics</a> <a class="post-tag" href="/tags/irsa/">irsa</a> <a class="post-tag" href="/tags/ml/">ml</a> <a class="post-tag" href="/tags/mlops/">mlops</a> <a class="post-tag" href="/tags/paper/">paper</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://gguguk.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-8EWVG7CHCY"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-8EWVG7CHCY'); }); </script>

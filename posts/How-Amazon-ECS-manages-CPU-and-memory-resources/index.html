<!DOCTYPE html><html lang="en" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Expires" content="0"><meta http-equiv="Pragma" content="no-cache"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="ECS의 task definition에서 soft/hard memory limit의 의미" /><meta name="author" content="Gukwon Koo" /><meta property="og:locale" content="en" /><meta name="description" content="본 포스트는 How Amazon ECS manages CPU and memory resources라는 글의 도움을 가장 많이 받았습니다. 본 포스트에 정리된 내용 보다 더 자세한 내용을 알고 싶으시면 해당 글을 참고해주세요." /><meta property="og:description" content="본 포스트는 How Amazon ECS manages CPU and memory resources라는 글의 도움을 가장 많이 받았습니다. 본 포스트에 정리된 내용 보다 더 자세한 내용을 알고 싶으시면 해당 글을 참고해주세요." /><link rel="canonical" href="https://gguguk.github.io/posts/How-Amazon-ECS-manages-CPU-and-memory-resources/" /><meta property="og:url" content="https://gguguk.github.io/posts/How-Amazon-ECS-manages-CPU-and-memory-resources/" /><meta property="og:site_name" content="생각과 고민." /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-06-20T10:14:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="ECS의 task definition에서 soft/hard memory limit의 의미" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Gukwon Koo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Gukwon Koo"},"dateModified":"2021-06-20T10:14:00+09:00","datePublished":"2021-06-20T10:14:00+09:00","description":"본 포스트는 How Amazon ECS manages CPU and memory resources라는 글의 도움을 가장 많이 받았습니다. 본 포스트에 정리된 내용 보다 더 자세한 내용을 알고 싶으시면 해당 글을 참고해주세요.","headline":"ECS의 task definition에서 soft/hard memory limit의 의미","mainEntityOfPage":{"@type":"WebPage","@id":"https://gguguk.github.io/posts/How-Amazon-ECS-manages-CPU-and-memory-resources/"},"url":"https://gguguk.github.io/posts/How-Amazon-ECS-manages-CPU-and-memory-resources/"}</script><title>ECS의 task definition에서 soft/hard memory limit의 의미 | 생각과 고민.</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="생각과 고민."><meta name="application-name" content="생각과 고민."><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/sample/bear.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">생각과 고민.</a></div><div class="site-subtitle font-italic">주니어 데이터 사이언티스트입니다.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/gguguk" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/%EA%B5%AD%EC%9B%90-%EA%B5%AC-32a9691a1/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>ECS의 task definition에서 soft/hard memory limit의 의미</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>ECS의 task definition에서 soft/hard memory limit의 의미</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Gukwon Koo </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Jun 20, 2021, 10:14 AM +0900" >Jun 20, 2021<i class="unloaded">2021-06-20T10:14:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2729 words">15 min read</span></div></div><div class="post-content"><blockquote><p>본 포스트는 <a href="https://aws.amazon.com/ko/blogs/containers/how-amazon-ecs-manages-cpu-and-memory-resources/">How Amazon ECS manages CPU and memory resources</a>라는 글의 도움을 가장 많이 받았습니다. 본 포스트에 정리된 내용 보다 더 자세한 내용을 알고 싶으시면 해당 글을 참고해주세요.</p></blockquote><p><br /></p><p>최근 ECS를 다루면서 task definition을 정의할 때 container의 memory resource를 설정해야하는 일이 있었습니다. 이때 아래 그림과 같이의 container의 memory limit 설정을 해야 했는데요. document를 읽어봐도 정확히 어떤 의미인지 이해하기 어려웠습니다. 따라서 관련된 내용을 찾아보았고 task의 lauch type에 따라서 다른 의미를 가지게 된다는 것을 알게 되었습니다. 저희 팀에서는 인프라 관리하는 일에 최대한 신경을 덜 쓰기 위해 container instance로 Fargate를 선택하였는데요. 따라서 본 포스트에서는 Fargate lauch type을 선택했을 때 memory limit 설정에서 <code class="language-plaintext highlighter-rouge">soft limit</code>와 <code class="language-plaintext highlighter-rouge">hard limit</code>가 가지는 의미를 중점적으로 살펴보겠습니다.</p><p>참고로 본 포스트는 docker container와 AWS ECS에 대한 기본적인 개념을 알고 있다는 가정에서 작성되었습니다. 틀린 설명이 있다면 지적해 주시면 감사 하겠습니다.</p><p><br /></p><p><img data-proofer-ignore data-src="/assets/img/post_img/ECS_task_definition_memory_limitation.png" alt="" /></p><p><br /></p><hr /><h1 id="ecs-document를-먼저-보자">ECS Document를 먼저 보자</h1><p>가장 먼저 task definition의 parameter가 설명되어 있는 <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#container_definitions">document</a>를 살펴봅시다. Container Definitions의 <code class="language-plaintext highlighter-rouge">memory</code>와 <code class="language-plaintext highlighter-rouge">memoryReservation</code> 부분의 설명을 보면 다음과 같이 설명되어 있습니다.</p><blockquote><p><code class="language-plaintext highlighter-rouge">memory</code></p><p>The amount (in MiB) of memory to present to the container. If your container attempts to exceed the memory specified here, the container is killed.</p><p><code class="language-plaintext highlighter-rouge">memoryReservation</code></p><p>The soft limit (in MiB) of memory to reserve for the container. When system memory is under contention, Docker attempts to keep the container memory to this soft limit</p></blockquote><p><code class="language-plaintext highlighter-rouge">memory</code> 파라미터는 container가 쓸 수 있는 메모리의 총량을 설정하는 것이고, container가 설정된 용량을 넘어서 메모리를 사용하려고 시도하면 컨테이너가 죽는다고 하네요. 음… 이정도면 어느 정도는 이해가 되는 것 같습니다. 컨테이너는 container instance를 기반으로 띄워지는 process인데 해당 process가 활용할 수 있는 메모리의 총량을 제한하는 것이군요.</p><p>그런데 <code class="language-plaintext highlighter-rouge">memoryReservation</code> 파라미터의 설명을 보면 한번에 이해가 가지는 않습니다. 일단 정의를 잃어보면, 컨테이너를 위해 예약된(reserve) 메모리의 soft limit라고 하네요. 이 말도 이해가 잘 안가고… 또 시스템 메모리가 경쟁 상태에 있으면 도커 데몬이 설정된 soft limit 만큼의 메모리를 컨테이너를 위해 keep을 한다고 합니다. 일단 전반적으로 어떤 말인지 잘 이해가 가지 않습니다. 그리고 메모리를 예약(reserve) 한다는 개념도 생소하고, 이 것이 왜 필요한지 모르겠네요. 배경 설명이 필요할 것 같습니다.</p><p><br /></p><hr /><h1 id="general-rules-of-thumb-with-containers">General rules of thumb with containers</h1><p>먼저 도커 컨테이너가 호스트의 리소스와 어떻게 상호 작용하는 지에 대해 간단히 정리해봅시다.</p><ul><li><a href="https://www.44bits.io/ko/post/is-docker-container-a-virtual-machine-or-a-process">도커 컨테이너는 프로세스</a>입니다. 다시 말해, 도커 컨테이너는 호스트에 떠 있는 여러 프로세스 중 하나일 뿐입니다.<li>프로세스들은 호스트의 cpu, memory, 기타 자원을 공유(share)합니다.<li>특별한 이유가 없다면, <strong>일반적으로 컨테이너는 호스트의 모든 cpu 및 메모리 자원에 접근하고 이를 활용할 수 있습니다.</strong><li>특별한 이유가 없다면, <strong>같은 호스트에 떠 있는 컨테이너들은 호스트의 CPU, memory, 기타 자원들을 공유합니다.</strong> 이는 호스트에 떠 있는 프로세스들이 자원을 공유하고 있는 것과 같은 이치입니다.</ul><p>사실 위의 설명은 컨테이너만이 가지는 특성이라기 보다는 리눅스 프로세스들의 일반적인 특성입니다.</p><hr /><h1 id="ecs-resource-management-options">ECS resource management options</h1><p>ECS에서 리소스와 관련된 설정은 크게 두 가지로 구분할 수 있습니다.</p><ul><li>Task &gt; Host<ul><li>task가 host의 리소스를 얼마나 예약해 둘 수 있으며 활용 가능한 리소스의 최대치를 얼마나 둘지에 대한 설정입니다.<li>launch type이 EC2일 때만 설정할 수 있습니다.<li>본 포스트에서 다루지 않습니다.</ul><li>Container &gt; Task<ul><li><strong>Task 내부의 container가 Task의 리소스</strong>를 얼마나 예약해 둘 수 있으며, 활용 가능한 리소스의 최대치를 얼마나 둘지에 대한 설정입니다.<li>launch type이 EC2일 때와 <strong>Fargate</strong>일 때 모두 설정할 수 있습니다.<li>본 포스트에서 다루는 부분입니다.</ul></ul><p>이와 같은 리소스에 관한 설정은 아래와 같이 task definition에서 정의됩니다.</p><div class="language-json highlighter-rouge"><div class="code-header" text-data="json"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="p">{</span><span class="w">
  </span><span class="nl">"containerDefinitions"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"cpu"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
      </span><span class="nl">"memory"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w">
      </span><span class="nl">"memoryReservation"</span><span class="p">:</span><span class="w"> </span><span class="mi">1024</span><span class="p">,</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"cpu"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1024"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"memory"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2048"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"compatibilities"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="s2">"EC2"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"FARGATE"</span><span class="w">
  </span><span class="p">],</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></table></code></div></div><p><br /></p><p>그렇다면 리소스를 예약하는 것이 무슨 의미를 가지며 왜 필요한 걸까요? <em>General rules of thumb with containers</em> 섹션에서 언급한 것처럼 하나의 호스트에는 여러 개의 프로세스가 떠 있으며 해당 프로세스들은 호스트의 리소스를 공유합니다.</p><p>리소스를 공유한다는 것은 해당 리소스를 활용하는 대상들(e.g., 컨테이너) 사이에 자원에 대한 경쟁(contend)이 발생할 수 있다는 것을 의미합니다. 만일 ECS에 올려서 배포하려는 어플리케이션이 다른 프로세스들과의 리소스 경쟁에서 밀린다면 해당 어플리케이션 기반의 서비스가 제대로 작동할 수 있을까요? 당연하게도 해당 애플리케이션은 제대로 동작하지 않을 것이고 이러한 서비스는 고객들의 불편함을 초래할 것입니다.</p><p>만일 서비스를 제공하는 컨테이너만이 활용할 수 있도록 미리 리소스를 예약(reservation) 해두면 어떨까요? 예약된 리소스는 해당 컨테이너만 활용할 수 있기 때문에 리소스 경쟁 때문에 애플리케이션이 실패하는 일을 미연에 방지할 수 있을 것입니다.</p><blockquote><p>Reservations are effectively telling ECS that “this specific containers needs this much memory and this much CPU”</p></blockquote><hr /><h1 id="soft-memory-limit-vs-hard-memory-limit">Soft Memory Limit vs Hard Memory Limit</h1><p>container instance로 Fargate를 선택한 경우, task가 host의 자원을 어떻게 활용할지에 대한 설정은 필요가 없습니다. EC2 launch type은 하나의 EC2에 복수 개의 task를 올릴 수 있고 각 task에는 복수 개의 컨테이너를 올릴 수 있습니다. 따라서 task를 만들 때 EC2 launch type을 선택하면 task가 호스트의 자원을 활용하는 설정와 container가 task의 자원을 활용하는 설정, 두 가지가 모두 필요합니다.</p><p>그러나 Fargate launch type은 각자가 완벽하게 분리되어 있기 때문에 각 task는 서로 간에 CPU나 메모리 등의 자원을 절대 공유하지 않습니다. 따라서 container가 task의 자원을 활용하는 것과 관련된 설정만 진행하면 됩니다.</p><blockquote><p>Each Fargate task has its own isolation boundary and does not share the underlying kernel, CPU resources, memory resources, or elastic network interface with another task.</p></blockquote><p>task definition의 <code class="language-plaintext highlighter-rouge">containerDefinitions</code>에 <code class="language-plaintext highlighter-rouge">memoryReservation</code> 필드가 예약 메모리와 관련된 설정입니다. 그리고 우리가 서두에서 보았던 memory의 <code class="language-plaintext highlighter-rouge">soft limit</code>는 사실 <code class="language-plaintext highlighter-rouge">memoryReservation</code> 필드에 들어갈 value를 정하는 것이었습니다. 한편 컨테이너가 활용할 수 있는 리소스의 최대치도 정할 수 있습니다. 이것이 바로 memory의 <code class="language-plaintext highlighter-rouge">hard limit</code> 설정이며, 해당 컨테이너가 <code class="language-plaintext highlighter-rouge">hard limit</code>를 초과하는 메모리를 사용하게 되면 해당 컨테이너는 죽게 됩니다. <code class="language-plaintext highlighter-rouge">hard limit</code>는 task definition에서 <code class="language-plaintext highlighter-rouge">memory</code>라는 필드명으로 등록됩니다.</p><blockquote><p>Hard and soft limits correspond to the <code class="language-plaintext highlighter-rouge">memory</code> and <code class="language-plaintext highlighter-rouge">memoryReservation</code> parameters, respectively, in task definitions.</p></blockquote><p>memory의 soft limit와 hard limit는 둘 다 선택할 수 있거나 둘 중 하나만 선택할 수도 있습니다. 각각의 경우에는 다음과 같은 의미를 가집니다.</p><ul><li>soft limit만 설정<ul><li>예약(reservation) 메모리: specified soft limit value<li>최대(ceiling) 메모리: specified task memory size</ul><li>soft limit와 hard limit 둘 다 설정<ul><li>예약(reservation): specified soft limit value<li>최대(ceiling): specified hard limit value</ul><li>hard limit만 설정<ul><li>예약(reservation): specified hard limit value<li>최대(ceiling): specified hard limit value</ul></ul><p>마지막으로 soft limit와 hard limit 둘 다 설정 했을 때의 예시를 통해 soft limit와 hard limit의 동작 원리를 이해해 봅시다.</p><blockquote><p>soft limit(<code class="language-plaintext highlighter-rouge">memoryReservation</code>): 256MB hard limit(<code class="language-plaintext highlighter-rouge">memory</code>): 512MB</p></blockquote><p>위와 같은 경우에는 컨테이너에 기본적으로 256MB의 메모리가 할당(예약)됩니다. 물론 예약된 메모리를 100% 다 활용하지 않을 수도 있습니다. 그러나 만일 메모리 사용량이 512MB를 넘어서게 되면 해당 컨테이너는 자동으로 종료됩니다.</p><hr /><h1 id="summary">Summary</h1><p>우리는 AWS document에 memory 및 memoryReservation 파라미터를 이해 해보려고 노력하는 것에서 이야기를 시작해보았습니다. 이해가 가는 부분도 있고, 배경 지식이 없으면 이해되지 않는 부분도 있었죠. 특히 메모리 “예약”이라는 개념을 이해하기 위한 설명이 주를 이루었습니다. 도커 컨테이너에 대한 일반적인 이야기와 ECS에서 리소스를 관리하는 여러가지 설정에 대한 이야기도 했습니다. 이를 통해서 메모리 예약이 왜 필요하고 ECS에서 어떤 파라미터가 이와 관련된 설정을 지정할 수 있는지에 대해서도 배웠습니다. 여기까지 글을 정독 하셨다면 ECS document에 적혀 있는 <code class="language-plaintext highlighter-rouge">memory</code> 및 <code class="language-plaintext highlighter-rouge">memoryReservation</code> 부분을 무리 없이 이해하실 수 있을 것 같습니다. 혹시 잘못된 설명이 있었다면 지적 부탁드립니다.</p><hr /><h1 id="references">References</h1><ul><li><a href="https://aws.amazon.com/ko/blogs/containers/how-amazon-ecs-manages-cpu-and-memory-resources/">How Amazon ECS manages CPU and memory resources</a><li><a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#container_definitions">Task definition parameters - container definition</a><li><a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html">Amazon ECS on AWS Fargate</a><li><a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cloudwatch-metrics.html">Amazon ECS CloudWatch metrics</a><li><a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html">Amazon ECS on AWS Fargate</a><li><a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/memory-management.html">Container Instance Memory Management</a><li><a href="https://www.44bits.io/ko/post/is-docker-container-a-virtual-machine-or-a-process">도커 컨테이너는 가상머신인가요? 프로세스인가요?</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/mlops/'>MLOps</a>, <a href='/categories/aws-ecs/'>AWS ECS</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/mlops/" class="post-tag no-text-decoration" >mlops</a> <a href="/tags/aws/" class="post-tag no-text-decoration" >aws</a> <a href="/tags/ecs/" class="post-tag no-text-decoration" >ecs</a> <a href="/tags/cpu/" class="post-tag no-text-decoration" >cpu</a> <a href="/tags/meory/" class="post-tag no-text-decoration" >meory</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=ECS의 task definition에서 soft/hard memory limit의 의미 - 생각과 고민.&url=https://gguguk.github.io/posts/How-Amazon-ECS-manages-CPU-and-memory-resources/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=ECS의 task definition에서 soft/hard memory limit의 의미 - 생각과 고민.&u=https://gguguk.github.io/posts/How-Amazon-ECS-manages-CPU-and-memory-resources/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=ECS의 task definition에서 soft/hard memory limit의 의미 - 생각과 고민.&url=https://gguguk.github.io/posts/How-Amazon-ECS-manages-CPU-and-memory-resources/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/tsne/">T-SNE 이해하기</a><li><a href="/posts/how_to_work_python/">CS50 - 파이썬이 소스 코드를 실행하는 과정과 원리</a><li><a href="/posts/OIDC/">IRSA의 원리를 파헤쳐보자 4 - OIDC</a><li><a href="/posts/OAuth/">IRSA의 원리를 파헤쳐보자 3 - OAuth2.0</a><li><a href="/posts/admission_webhook/">IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook</a></ul></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Bastion_ALB/"><div class="card-body"> <span class="timeago small" >Jun 20, 2021<i class="unloaded">2021-06-20T10:14:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Bastion에서 internet-facing ALB로 요청을 보내고 응답 받기</h3><div class="text-muted small"><p> Bastion에서 ELB로 요청을 보내고 응답 받기 Keyword security group(보안 그룹), security group chaining, ELB(Elastic Load Balancer) 같은 AWS VPC 내부 존재하는 public ip를 가진 bastion에서 internet-facing ALB에 HTTP req...</p></div></div></a></div><div class="card"> <a href="/posts/MLOps/"><div class="card-body"> <span class="timeago small" >Oct 17, 2021<i class="unloaded">2021-10-17T16:17:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MLOps - Continuous delivery and automation pipelines in machine learing 번역 및 요약 정리</h3><div class="text-muted small"><p> MLOps에 대한 레퍼런스를 찾아 보던 중 개념을 잡기에 좋은 글을 발견하여 번역 및 요약 정리합니다. 원문은 MLOps: Continuous delivery and automation pipelines in machine learing를 참조해주세요. 한글로 번역할 경우에 뜻이 모호해지는 경우에는 영어 그대로 쓰거나 한글과 영문을 병기하였습니다...</p></div></div></a></div><div class="card"> <a href="/posts/admission_webhook/"><div class="card-body"> <span class="timeago small" >Sep 13, 2022<i class="unloaded">2022-09-13T23:25:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook</h3><div class="text-muted small"><p> IRSA(IAM Role for Service Account)는 AWS EKS에서 파드 단위로 권한을 관리하기 위한 방법 또는 프로세스입니다. 요즘에 회사에서 kubeflow를 셋팅하고 있는데 AWS의 특정 리소스(S3 등)와의 통신을 위해 파드에 일정 권한을 부여해야할 상황이 자주 발생합니다. 저는 이때 주로 IRSA를 활용하여 업무를 진행하고 있습...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/retrospective/" class="btn btn-outline-primary" prompt="Older"><p>글또 5기 회고글</p></a> <a href="/posts/Bastion_ALB/" class="btn btn-outline-primary" prompt="Newer"><p>Bastion에서 internet-facing ALB로 요청을 보내고 응답 받기</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/gguguk">Gukwon Koo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/retrospective/">retrospective</a> <a class="post-tag" href="/tags/k8s/">k8s</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/nlp/">nlp</a> <a class="post-tag" href="/tags/statistics/">statistics</a> <a class="post-tag" href="/tags/irsa/">irsa</a> <a class="post-tag" href="/tags/ml/">ml</a> <a class="post-tag" href="/tags/mlops/">mlops</a> <a class="post-tag" href="/tags/paper/">paper</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://gguguk.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-8EWVG7CHCY"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-8EWVG7CHCY'); }); </script>

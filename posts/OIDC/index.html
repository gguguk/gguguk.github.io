<!DOCTYPE html><html lang="en" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Expires" content="0"><meta http-equiv="Pragma" content="no-cache"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="IRSA의 원리를 파헤쳐보자 4 - OIDC" /><meta name="author" content="Gukwon Koo" /><meta property="og:locale" content="en" /><meta name="description" content="지난 글에서는 OAuth2.0를 살펴보았습니다. OAuth2.0을 이해해야 본 글에서 설명할 OIDC를 이해할 수 있습니다. OIDC는 인증(authentication)을 위한 프로토콜입니다." /><meta property="og:description" content="지난 글에서는 OAuth2.0를 살펴보았습니다. OAuth2.0을 이해해야 본 글에서 설명할 OIDC를 이해할 수 있습니다. OIDC는 인증(authentication)을 위한 프로토콜입니다." /><link rel="canonical" href="https://gguguk.github.io/posts/OIDC/" /><meta property="og:url" content="https://gguguk.github.io/posts/OIDC/" /><meta property="og:site_name" content="생각과 고민." /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-12-20T21:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="IRSA의 원리를 파헤쳐보자 4 - OIDC" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Gukwon Koo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Gukwon Koo"},"dateModified":"2023-01-19T21:49:51+09:00","datePublished":"2022-12-20T21:00:00+09:00","description":"지난 글에서는 OAuth2.0를 살펴보았습니다. OAuth2.0을 이해해야 본 글에서 설명할 OIDC를 이해할 수 있습니다. OIDC는 인증(authentication)을 위한 프로토콜입니다.","headline":"IRSA의 원리를 파헤쳐보자 4 - OIDC","mainEntityOfPage":{"@type":"WebPage","@id":"https://gguguk.github.io/posts/OIDC/"},"url":"https://gguguk.github.io/posts/OIDC/"}</script><title>IRSA의 원리를 파헤쳐보자 4 - OIDC | 생각과 고민.</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="생각과 고민."><meta name="application-name" content="생각과 고민."><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/sample/bear.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">생각과 고민.</a></div><div class="site-subtitle font-italic">주니어 데이터 사이언티스트입니다.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/gguguk" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/%EA%B5%AD%EC%9B%90-%EA%B5%AC-32a9691a1/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>IRSA의 원리를 파헤쳐보자 4 - OIDC</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>IRSA의 원리를 파헤쳐보자 4 - OIDC</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Gukwon Koo </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Dec 20, 2022, 9:00 PM +0900" >Dec 20, 2022<i class="unloaded">2022-12-20T21:00:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Jan 19, 2023, 9:49 PM +0900" >Jan 19, 2023<i class="unloaded">2023-01-19T21:49:51+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4728 words">26 min read</span></div></div><div class="post-content"><p>지난 글에서는 OAuth2.0를 살펴보았습니다. OAuth2.0을 이해해야 본 글에서 설명할 OIDC를 이해할 수 있습니다. OIDC는 인증(authentication)을 위한 프로토콜입니다.</p><p>IRSA의 원리를 파헤쳐보자 시리즈</p><ol><li><a href="https://gguguk.github.io/posts/admission_webhook/">IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook</a><li><a href="https://gguguk.github.io/posts/service_account_volume_projection/">IRSA의 원리를 파헤쳐보자 2 - K8S Sevice Account와 Service Account Token Volume Projection</a><li><a href="https://gguguk.github.io/posts/OAuth/">IRSA의 원리를 파헤쳐보자 3 - OAuth2.0</a><li><u>IRSA의 원리를 파헤쳐보자 4 - OIDC</u><li>IRSA의 원리를 파헤쳐보자 5 - IRSA Process</ol><p><br /></p><h1 id="oidcopenid-connect">OIDC(OpenID Connect)</h1><h3 id="oidc란">OIDC란?</h3><p><strong>OIDC(OpenID Connect)란 <u>OAuth 위에서</u> 동작하는 사용하는 인증(authentication)을 위한 프로토콜</strong>입니다. 앞서 우리는 위에서 OAuth2.0에 대해서 배웠습니다. 인가를 담당하는 표준화된 프로토콜이라고 했죠. 그리고 인가를 하기 위해서 필연적으로 인증 과정이 수반되었습니다(구글 로그인, 페이스북 로그인 등) 이러한 사실 때문에 많은 사람들이 OAuth를 인가와 인증 두 가지 목적을 모두 담당하는 프로토콜이라고 오해하고 있습니다.(저도 포함입니다… 🙋‍♀️)</p><p><br /></p><h3 id="oidc와-oauth를-구분하자">OIDC와 OAuth를 구분하자</h3><p><img data-proofer-ignore data-src="/assets/img/post_img/OIDC_metaphor.png" alt="" /><em>사탕의 맛을 내기 위한 재료들과 사탕이 있습니다. 각각 인가와 인증으로 비유할 수 있습니다.</em></p><p>그러나 이는 엄청난 오해입니다. <a href="https://oauth.net/articles/authentication/#:~:text=Authentication%20vs.%20Authorization%3A%20a%20metaphor">비유를 들어서</a> 쉽게 설명해보겠습니다(이해를 돕기 위한 비약이 있을 수 있습니다). 사탕의 맛을 내기 위한 재료들이 있습니다. 오렌지, 딸기, 초콜릿 등이 있습니다. 이런 재료들은 그 자체로도 충분히 우리의 먹거리가 되어줍니다. 그리고 사탕도 많은 종류가 있습니다. 오렌지 맛 사탕, 딸기 맛 사탕, 초콜릿 맛 사탕을 예시로 들 수 있습니다. 여기서 중요한 점은 초콜릿과 초콜릿 맛 사탕은 서로 깊은 연관이 있지만, 결국엔 서로 다르다는 것입니다.</p><p>이 비유에서 사탕의 맛을 내기 위한 재료들은 인가(authorization)를 구현하기 위한 여러가지 기술 또는 프로토콜이라고 할 수 있습니다. 그 중 가장 대중적으로 쓰이는 프로토콜이 바로 초콜릿, OAuth 2.0입니다. 그리고 초콜릿은 그 자체로 간식으로 먹는 것처럼 OAuth 2.0도 인가의 기능을 그 자체로 담당할 수 있습니다. 한편 사탕은 인증(authentication)을 구현하기 위한 기술 또는 프로토콜입니다. 특히 OIDC는 OAuth2.0에 기반을 둔 대표적인 프로토콜인데요, 일명 초콜릿 맛 사탕이라고 할 수 있겠습니다.</p><p>이처럼 OAuth(초콜릿)와 OIDC(초콜릿 맛 사탕)는 뗄려야 뗄 수 없는 관계입니다. 그러나 이 둘은 서로 엄연히 다른 목적을 가지고 있으며, OAuth와 OIDC를 혼동하는 것은 <a href="https://oauth.net/articles/authentication/">OAuth 공식 문서</a>에서도 지적하고 있는 매우 중대한 오류입니다(그 이유에 대해서는 부록에 번역 및 작성해 두었습니다). OAuth는 인가를 위한 프로토콜인데, 특정 범위(scope)의 권한을 인가하기 위해서는 어쩔 수 없이 인증의 과정을 거치기는 합니다. 그러나 OAuth 흐름에서 발생하는 인증은 OAuth 프로토콜의 본래의 목적이 아니라 하나의 수단에 불과합니다. 한편 OIDC는 OAuth 위에서 동작하는 인증 프로토콜입니다. OAuth가 인가를 위해 어쩔 수 없이 인증 과정을 거치는데, 이 과정에서 OIDC는 인증을 위해 사용자의 신원을 식별하는데 활용 되는 <code class="language-plaintext highlighter-rouge">id_token</code>을 추가적으로 발급합니다(이때 OAuth는 access_token`을 발급합니다).</p><p><br /></p><h1 id="oidc-주체">OIDC 주체</h1><p>OIDC는 OAuth2.0 위에서 동작하는 프로토콜이지만, OIDC에 참여하는 주체들의 명칭은 OAuth2.0과 조금 다릅니다.</p><ul><li><p>OpenID provider(IdP): ID token을 발급하는 인가 서버(authorization server)입니다. OAuth2.0에서의 인가 서버에 해당합니다.</p><li><p>End user: 인증하는 주체입니다. OAuth2.0에서의 리소스 소유자(Resource owner)에 해당합니다.</p><li><p>Relying party: OpenID provider에 id token을 요청하는 주체입니다. OAuth2.0에서의 클라이언트에 해당합니다.</p></ul><p><br /></p><h1 id="oidc에서-id-token을-발급-받는-과정">OIDC에서 id token을 발급 받는 과정</h1><p><img data-proofer-ignore data-src="/assets/img/post_img/oidc_flow.png" alt="" width="650" /></p><p>OIDC는 OAuth 위에서 동작하는 프로토콜입니다. 따라서 <a href="https://gguguk.github.io/posts/OAuth/#oauth20%EC%9D%98-%EB%8F%99%EC%9E%91-%ED%9D%90%EB%A6%84%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98">이전 OAuth2.0</a> 글에서 언급했던 플로우를 거의 그대로 따릅니다. 다만 다음과 같은 부분에서 차이가 있습니다:</p><ul><li>로그인 페이지 요청시 <code class="language-plaintext highlighter-rouge">scope=openid</code>를 반드시 명시합니다. 이 경우에만 추후 <code class="language-plaintext highlighter-rouge">id_token</code>이라는 사용자의 신원을 확인할 수 있는 토큰이 발급됩니다.<li><code class="language-plaintext highlighter-rouge">access_token</code> 교환 요청이 성공적으로 수행되면 기존 OAuth2.0에서 발급되었던 <code class="language-plaintext highlighter-rouge">access_token</code>과 <code class="language-plaintext highlighter-rouge">refresh_token</code> 이외에 <code class="language-plaintext highlighter-rouge">id_token</code>이 추가 발급됩니다.</ul><p><br /></p><p>발급된 id_token을 크게 <a href="https://dexidp.io/docs/using-dex/">2가지 용도</a>로 사용될 수 있습니다.</p><ul><li>클라이언트(relying party, 애플리케이션)가 유저를 자체적으로 인증 용도(e.g., 카카오 아이디로 로그인 등)<li>클라이언트가 다른 서비스에 인증하는 용도(e.g., k8s의 파드가 id_token을 이용하여 k8s api server에 인증)</ul><p>이 중 클라이언트가 유저를 인증하는 용도로 사용되는 것이 더 일반적인 경우입니다. 그리고 이 과정은 <code class="language-plaintext highlighter-rouge">id_token</code>을 검증하고, <code class="language-plaintext highlighter-rouge">id_token</code>에 담겨 있는 정보를 조회해서 내부 DB와 교차 검증을 하는 순서로 진행됩니다. 이를 이해하기 위해서 <code class="language-plaintext highlighter-rouge">id_token</code>이 실제로 어떻게 생겼는지 살펴봅시다.</p><p><br /></p><h3 id="id_token">id_token</h3><p><code class="language-plaintext highlighter-rouge">id_token</code>이 <code class="language-plaintext highlighter-rouge">access_token</code>과 가장 크게 구별되는 점은 <strong>실제로 사용자와 관련된 정보</strong>를 담고 있다는 점입니다. <code class="language-plaintext highlighter-rouge">id_token</code>은 크게 <strong>헤더(Header)</strong>, <strong>페이로드(Payload)</strong>, <strong>서명(Signature)</strong>라는 총 3개의 파트가 온점(.)으로 구분된 스트링입니다. 원 형태는 JWT(Json Web Token)이지만, 이를 각 파트별로 base64로 인코딩한 후 온점(.)으로 구분합니다. 실제 <code class="language-plaintext highlighter-rouge">id_token</code>은 다음과 같은 형태입니다. 디코딩 된 실제 값은 <a href="https://jwt.io/#debugger-io?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczovL2thdXRoLmtha2FvLmNvbSIsImF1ZCI6Imtvby1hcHAiLCJzdWIiOiJnd2tvbzgyQGdtYWlsLmNvbSIsImV4cCI6MTM1MzYwNDkyNiwiaWF0IjoxMzUzNjAxMDI2fQ.W2IPamKaQ5Ea18ElKmztPI8a71b9hkhhz5RD7EioU6g">여기</a>를 참조해주세요.</p><blockquote><p><code class="language-plaintext highlighter-rouge">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</code>.<code class="language-plaintext highlighter-rouge">eyJpc3MiOiJodHRwczovL2thdXRoLmtha2FvLmNvbSIsImF1ZCI6Imtvby1hcHAiLCJzdWIiOiJnd2tvbzgyQGdtYWlsLmNvbSIsImV4cCI6MTM1MzYwNDkyNiwiaWF0IjoxMzUzNjAxMDI2fQ</code>.<code class="language-plaintext highlighter-rouge">PEST2li71tPylFlh13cZDC_JqyCq13jLxIJt8vyNpLQ</code></p></blockquote><p><br /></p><p><code class="language-plaintext highlighter-rouge">Header</code>에는 토큰의 타입과 이 토큰을 서명할 때 어떤 암호화 알고리즘을 사용하였는지, 토큰의 유형은 무엇인지 명시되어 있습니다. 주로 사용되는 암호화 알고리즘은 HS256(HMAC SHA256)<sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>이나 RSA입니다. 참고로 <a href="https://medium.com/jongho-developer/jwt-algorithm-hs256-rs256-1ab9f833c486">HS256은 대칭키 암호화 방식, RSA는 비대칭키 암호화 방식</a>입니다.</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="p">{</span>
  <span class="sh">"</span><span class="s">alg</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">HS256</span><span class="sh">"</span><span class="p">,</span> <span class="c1"># 해시 알고리즘 (HMAC, SHA256, RSA)
</span>  <span class="sh">"</span><span class="s">typ</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">JWT</span><span class="sh">"</span> <span class="c1"># 토큰 유형
</span><span class="p">}</span>
</pre></table></code></div></div><p><br /> <code class="language-plaintext highlighter-rouge">Payload</code>는 JWT의 핵심 내용이 명시 되어 있는 부분으로 여러 종류의 claim<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>으로 구성되어 있습니다.</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="p">{</span>
  <span class="sh">'</span><span class="s">iss</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">https://kauth.kakao.com</span><span class="sh">'</span><span class="p">,</span> 
  <span class="sh">'</span><span class="s">aud</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">koo-app</span><span class="sh">'</span><span class="p">,</span> 
  <span class="sh">'</span><span class="s">sub</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">gwkoo82@gmail.com</span><span class="sh">'</span><span class="p">,</span> 
  <span class="sh">'</span><span class="s">exp</span><span class="sh">'</span><span class="p">:</span> <span class="mi">1353604926</span><span class="p">,</span>
  <span class="sh">'</span><span class="s">iat</span><span class="sh">'</span><span class="p">:</span> <span class="mi">1353601026</span>
<span class="p">}</span>
</pre></table></code></div></div><p>특히 중요한 claim들은 다음과 같습니다.</p><ul><li><code class="language-plaintext highlighter-rouge">iss</code>(<em>issuer</em>): <code class="language-plaintext highlighter-rouge">id_token</code>을 발급한 주체(e.g., google, facebook, kakao, …)<li><code class="language-plaintext highlighter-rouge">aud</code>(<em>audience</em>): <code class="language-plaintext highlighter-rouge">id_token</code>을 활용하는 주체(e.g., 클라이언트, aws.sts)<li><code class="language-plaintext highlighter-rouge">sub</code>(<em>subject</em>): 리소스 오너(resource owner), 엔드 유저(end-user) (e.g., 사용자, 쿠버네티스 pod)<li><code class="language-plaintext highlighter-rouge">exp</code>: <code class="language-plaintext highlighter-rouge">id_token</code> 만료 시점<li><code class="language-plaintext highlighter-rouge">iat</code>: <code class="language-plaintext highlighter-rouge">id_token</code> 발급 시점</ul><p><br /></p><p>마지막으로 Signature(서명)는 <code class="language-plaintext highlighter-rouge">id_token</code>이 중간에 변조되진 않았는지, 유효성을 검사하기 위해 필요한 파트입니다. 대략 아래와 같은 pseudo 코드를 거쳐서 만들어집니다(HS256 알고리즘 기준).</p><div class="language-python highlighter-rouge"><div class="code-header" text-data="python"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nc">HMACSHA256</span><span class="p">(</span>
  <span class="nf">base64UrlEncode</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">+</span> <span class="sh">"</span><span class="s">.</span><span class="sh">"</span> <span class="o">+</span>
  <span class="nf">base64UrlEncode</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span>
  <span class="n">SECRET_VALUE</span>
<span class="p">)</span>
</pre></table></code></div></div><p>이렇게 해시값으로 암호화된 서명은 값은 (HS256 기준) 암호화에 사용된 <code class="language-plaintext highlighter-rouge">SECRET_VALUE</code>가 있다면 복호화가 가능합니다. 따라서 메시지에 실린 JWT의 header나 payload가 변조되었는지 여부를 서명을 복호화 한 다음, 서명시 같이 포함한 header와 payload 값과 비교해보면 곧바로 확인 가능합니다.</p><p><br /></p><h3 id="id_token-검증-과정">id_token 검증 과정</h3><ol><li>온점을 기준으로 id_token의 값을 헤더, 페이로드, 서명 부분으로 분리합니다.<li>페이로드를 base64 디코딩 합니다.<li>iss가 실제 발급자와 일치하는지 확인합니다.<li>aud가 현재 자기 자신 application의 키와 일치하는지 확인합니다.<li>exp가 현재 유닉스 타임보다 큰 값인지, 즉 만료되었는지 확인합니다.<li>마지막으로 서명의 변조 여부를 확인합니다.</ol><p><br /></p><h1 id="서명을-이해해-보자">서명을 이해해 보자.</h1><p><img data-proofer-ignore data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Avalanche_effect.svg/300px-Avalanche_effect.svg.png" alt="img" width="500" /><em><a href="https://ko.wikipedia.org/wiki/SHA-1">SHA-1</a>은 쇄도효과의 좋은 예시입니다. 1비트만 바꿔도 결과 값이 완전히 달라집니다.</em></p><p>지금까지 글의 논지를 살펴보면 OIDC flow는 인증 서버에서 <code class="language-plaintext highlighter-rouge">id_token</code>이라는 것을 클라이언트(relying party)에게 발급 해주는 과정이라고 할 수 있습니다. 그리고 클라이언트는 이 토큰을 활용해서 다른 서비스에 인증을 하는데 활용할 수 있는데요. 이 과정에서 ‘다른 서비스’는 해당 토큰이 원 형태를 유지한 채 변조 되지 않았다는 사실을 검증해야 합니다. 그리고 토큰의 유효성을 검증 하기 위해서는 서명(signature) 파트의 값을 활용합니다. 그렇다면 도대체 서명은 어떻게 하고, 이에 대한 검증은 어떻게 한다는 걸까요? 이 부분이 궁금해서 조금 더 찾아보게 되었습니다.</p><p>먼저 <a href="https://auth0.com/blog/rs256-vs-hs256-whats-the-difference/">서명은 암호화를 하는 것이 아님을 주의해야합니다</a>. 어떤 데이터를 암호화 한다는 것은 그것을 사람이 쉽게 읽지 못하게 만든다는 것인데, 서명은 데이터를 읽지 못하게 하는 것이 아니라, 데이터가 ‘변조’ 되었는지 아닌지 여부만 체크하는데 활용됩니다. 변조 여부를 체크할 수 있는 것은 <a href="https://ko.wikipedia.org/wiki/%EC%87%84%EB%8F%84_%ED%9A%A8%EA%B3%BC">해시 함수의 쇄도 효과(산사태 효과, avalanche effect)</a>의 원리에 기반합니다. 어떤 메시지가 아주 조금만 달라져도, 즉 변조가 아주 미세하게만 일어나도 해시값은 크게 바뀐다는 것입니다.</p><p>이와 같은 사실을 숙지하고, HS256 알고리즘을 서명 및 검증이 어떻게 이루어지는지 살펴봅시다. 생각보다 매우 간단합니다. 먼저 서명하는 쪽과 검증을 하는 쪽은 ‘대칭키’를 공유하고 있어야 합니다. 키라는 것은 일종의 문자열인데, 해시 함수는 결국 문자열을 비트로 변환한 후 특정 로직을 수행하므로 문자열을 그대로 사용하진 않습니다. 그리고 다음과 같이 헤더와 페이로드를 각각 base64로 인코딩 한뒤, 서로 공유 했던 대칭키와 함께 HS256을 이용해 메시지를 해시값으로 변환 합니다. 최종적으로 JWT의 ‘서명’ 부분에 이 해시값이 들어가서 전송됩니다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header" text-data="plaintext"><button data-original-title="Copied!"><i class="far fa-clone"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  SECRET_VALUE
)
</pre></table></code></div></div><p>이 메시지를 받는 쪽에서 해당 메시지가 변조 되었는지 어떻게 확인할 수 있을까요? 메시지를 받는 쪽은 기본적으로 JWT를 받았기 때문에 헤더와 페이로드 정보를 알 수 있습니다. 그리고 대칭키도 역시 사전에 공유되었으므로 알고 있는 정보입니다. 그럼 다시 위에 수도 코드를 실행할 수 있고, 해시값을 얻을 수 있을텐데요. 이를 전송 받았던 JWT의 서명 파트에 있는 해시와 비교 해보면 됩니다. 만일 내가 전달 받은 헤더나 페이로드가 원래 메시지와 달라졌다면 HS256의 결과인 해시값은 JWT의 서명 파트에 있는 값과 크게 차이가 날 것입니다.</p><p><br /></p><h1 id="access-token-vs-id-token">Access token vs id token</h1><div class="table-wrapper"><table><thead><tr><th> <th>access token<th>id token<tbody><tr><td>audience<td>Access tokens are meant to be read by the resource server(Access tokens must not be read or interpreted by the OAuth client. The OAuth client is not the intended audience of the token).<td>ID tokens are meant to be read by the OAuth client<tr><td>information<td>Access tokens do not convey user identity or any other information about the user to the OAuth client.<td>An ID token contains information about what happened when a user authenticated. The ID token may also contain information about the user such as their name or email address, although that is not a requirement of an ID token.<tr><td>usage<td>Access tokens should <em>only</em> be used to make requests to the resource server.<td><a href="https://oauth.net/id-tokens-vs-access-tokens/">ID tokens</a> must <em>not</em> be used to make requests to the resource server.<tr><td>form<td><a href="https://oauth.net/2/jwt-access-tokens/">can be JWTs</a> but may also be a random string<td><a href="https://oauth.net/2/jwt/">JWTs</a></table></div><p><br /></p><h1 id="부록">부록</h1><h2 id="access_token을-유저-인증에-사용하면-안될까">access_token을 유저 인증에 사용하면 안될까?</h2><p>여기까지 오셨으면 OIDC와 OAuth와의 미묘한 차이를 이해하셨 것이라 생각합니다. 그런데 이렇게 생각해볼 수 있지 않을까요? OAuth는 어쨌든 인증 과정을 거쳐서 access_token을 발급해주었으니까 access_token을 인증 과정에 사용해도 되지 않을까요? 결론부터 말하면 이는 틀린 생각입니다. <a href="https://oauth.net/articles/authentication/">oauth.net</a>에서는 OAuth로 인증을 하는 것의 위험성(<em>Common pitfalls for authentication using OAuth</em>)에 대해서 언급합니다.</p><h3 id="access-token에는-유저를-식별할-수-있는-정보가-없습니다">access token에는 유저를 식별할 수 있는 정보가 없습니다</h3><p>access token을 발급 받는 과정에 사용자 인증이 선행되기 때문에 OAuth 자체가 인증도 담당하고 있다고 생각할 수 있습니다. 그러나 access token은 근본적으로 client를 위한 개념이 아닙니다. 다시말해, access token의 audience(토근 발급 대상, 토근의 최종 사용 주체)는 client가 아니라 resource server(protected resource)입니다. client 입장에서 access token은 아무런 의미 없는 string에 불과합니다(<em>the token is designed to be opaque to the client</em>). 극단적으로 말하면, access token의 포맷이 바뀌었어도 authorization server와 resource server간의 로직만 이상없다면 client 입장에서는 신경 쓸 일이 전혀 없습니다. 그저 resource server로 access token을 전달하기만 하면 되니까요. 또한 access token에는 사용자와 관련된 데이터(<code class="language-plaintext highlighter-rouge">user_id</code>나 <code class="language-plaintext highlighter-rouge">email</code> 등)는 전혀 없으므로 클라이언트가 사용자를 식별할 수 있는 방법은 없습니다. client가 access token으로 사용자를 식별한다는 행위는 애초에 불가능한 행위라는 것입니다.</p><h3 id="유저의-인증-없이도-access-token이-발급될-수-있습니다">유저의 인증 없이도 access token이 발급될 수 있습니다.</h3><p>OAuth 과정에서 유저의 로그인을 통해 인증을 수행하고 최종적으로 access token을 발급 받을 수 있습니다. 그러나 이것이 access token을 발급 받을 수 있는 유일한 방법은 아닙니다. refresh token을 활용하여 유저의 인증 없이도 access token을 새로 발급 받을 수도 있습니다. 즉 access token을 발급 받았다는 사실 자체가 유저가 인증되었음을 완벽하게 보장할 수 없다는 뜻입니다.</p><h3 id="인증-서버가-아닌-제-3자가-access-token을-주입할-수도-있습니다">인증 서버가 아닌 제 3자가 access token을 주입할 수도 있습니다.</h3><p>만일 acces token이 URL 파라미터로 전달되는 implicit flow를 따르고, client가 access token의 유효성을 점검할 수 있는 메커니즘이 없다면 access token의 진위 여부를 판별하기 어렵습니다. 따라서 access token만으로 유저가 진짜로 인증했는지 여부를 판별하기 어렵습니다.</p><h3 id="access-token을-발급-해준-client인지-여부를-검증하는-메커니즘이-없습니다">access token을 발급 해준 client인지 여부를 검증하는 메커니즘이 없습니다.</h3><p>예를 들어, A라는 client가 정상적인 방법을 통해 access token을 발급 받은 후에 B라는 client가 해당 access token을 그대로 사용한다면, 일반적인 OAuth API들은 client를 검증하는 메커니즘이 없으므로 정상적으로 resource server와 통신이 일어날 것입니다. B라는 client가 A라는 client가 발급 받은 access token을 사용함에 있어서 유저의 인증은 개입되지 않았다는 점에서 access token으로 유저 인증을 하기에는 부족한 면이 있습니다.</p><h3 id="access-token에-대한-표준-형식이-없습니다">access token에 대한 표준 형식이 없습니다.</h3><p>OAuth 상에서 유저 인증 과정을 처리하려는 시도에 있어서 가장 큰 문제점은 access token의 <a href="https://www.rfc-editor.org/rfc/rfc6749#section-1.4">표준 형식이 정해져있지 않다는 것</a>입니다(<em>access tokens can have different formats, structures, and methods of utilization</em>) 예를 들어서 google에서는 유저의 아이디를 user_id 필드에 넘겨주는데, 페이스북에서는 subject 필드에 넘겨줄 수도 있습니다. 두 필드는 의미상으로는 동일하지만, 이를 처리하기 위해서는 서로 다른 방식으로 처리하는 코드를 짜야하기 때문에 번거롭습니다.</p><p><br /></p><h1 id="참고자료">참고자료</h1><ul><li><a href="https://stackoverflow.com/questions/28418360/jwt-json-web-token-audience-aud-versus-client-id-whats-the-difference">JWT (Json Web Token) Audience “aud” versus Client_Id - What’s the difference?</a><li><a href="https://6991httam.medium.com/oauth%EB%9E%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-openid-8c46a65616e6">OAuth 그리고 OpenID Connect</a><li><a href="https://oauth.net/id-tokens-vs-access-tokens/">ID Tokens vs Access Tokens</a><li><a href="https://auth0.com/blog/id-token-access-token-what-is-the-difference/">ID Token and Access Token: What’s the Difference?</a><li><a href="https://bcho.tistory.com/999">JWT(JSON Web Token)을 이용한 API 인증 - #1 개념 소개</a><li><a href="https://ssup2.github.io/theory_analysis/OIDC/">OIDC (OpenID Connect)</a><li><a href="https://gguguk.github.io/posts/oidc/">인증과 인가 (권한 부여) 비교 – 특징 및 차이점</a><li><a href="https://hudi.blog/open-id/">OpenID(OIDC) 개념과 동작원리</a><li><a href="https://gruuuuu.github.io/security/ssofriends/">호다닥 공부해보는 SSO와 친구들 (SAML, OAuth, OIDC)</a><li><a href="https://developer.okta.com/docs/concepts/oauth-openid/">OAuth 2.0 and OpenID Connect Overview</a><li><a href="https://developers.kakao.com/docs/latest/ko/kakaologin/common#oidc">카카오 로그인 - OpenID Connect</a><li><a href="https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=alice_k106&amp;logNo=221598325656">쿠버네티스 인증 3편: Dex와 Github OAuth (OIDC) 를 이용한 사용자 인증하기</a><li><a href="https://medium.com/jongho-developer/jwt-algorithm-hs256-rs256-1ab9f833c486">JWT algorithm: HS256, RS256</a><li><a href="https://auth0.com/blog/rs256-vs-hs256-whats-the-difference/">RS256 vs HS256: What’s The Difference?</a><li><a href="https://ko.wikipedia.org/wiki/%EC%87%84%EB%8F%84_%ED%9A%A8%EA%B3%BC">해시 함수 - 쇄도 효과</a></ul><div class="footnotes" role="doc-endnotes"><ol><li id="fn:2"><p>HMAC(Hash-based Message Authentication Code) + SHA(Secure Hash Algorithm)-256)를 뜻합니다. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:1"><p>JWT에서 claim이란 프로퍼티나 속성을 말합니다. <code class="language-plaintext highlighter-rouge">"iss": "https://abc.com"</code> 를 하나의 claim이라고 할 수 있으며, <code class="language-plaintext highlighter-rouge">iss</code>를 claim 이름, <code class="language-plaintext highlighter-rouge">https://abc.com</code>을 claim 값이라고 합니다. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p></ol></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/mlops/'>MLOps</a>, <a href='/categories/kubernetes/'>Kubernetes</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/kubernetes/" class="post-tag no-text-decoration" >kubernetes</a> <a href="/tags/k8s/" class="post-tag no-text-decoration" >k8s</a> <a href="/tags/oauth2-0/" class="post-tag no-text-decoration" >oauth2.0</a> <a href="/tags/oidc/" class="post-tag no-text-decoration" >oidc</a> <a href="/tags/irsa/" class="post-tag no-text-decoration" >irsa</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=IRSA의 원리를 파헤쳐보자 4 - OIDC - 생각과 고민.&url=https://gguguk.github.io/posts/OIDC/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=IRSA의 원리를 파헤쳐보자 4 - OIDC - 생각과 고민.&u=https://gguguk.github.io/posts/OIDC/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=IRSA의 원리를 파헤쳐보자 4 - OIDC - 생각과 고민.&url=https://gguguk.github.io/posts/OIDC/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/tsne/">T-SNE 이해하기</a><li><a href="/posts/how_to_work_python/">CS50 - 파이썬이 소스 코드를 실행하는 과정과 원리</a><li><a href="/posts/OIDC/">IRSA의 원리를 파헤쳐보자 4 - OIDC</a><li><a href="/posts/OAuth/">IRSA의 원리를 파헤쳐보자 3 - OAuth2.0</a><li><a href="/posts/admission_webhook/">IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/service_account_volume_projection/"><div class="card-body"> <span class="timeago small" >Oct 26, 2022<i class="unloaded">2022-10-26T22:12:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>IRSA의 원리를 파헤쳐보자 2 - K8S Sevice Account와 Service Account Token Volume Projection</h3><div class="text-muted small"><p> IRSA의 원리를 파헤쳐보자 시리즈의 마지막 글입니다. 저번 글에서는 admission webhook을 학습했습니다. 요약하자면 EKS 클러스터를 설치하면 control plane에 pod identity webhook이라는 webhook server(일종의 API 서버)가 함께 배포되고, pod identity webhook은 서비스 어카운트에 ia...</p></div></div></a></div><div class="card"> <a href="/posts/OAuth/"><div class="card-body"> <span class="timeago small" >Nov 26, 2022<i class="unloaded">2022-11-26T20:04:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>IRSA의 원리를 파헤쳐보자 3 - OAuth2.0</h3><div class="text-muted small"><p> IRSA의 원리를 파헤쳐보자 시리즈의 세번째 글입니다. 지난 시간에는 service account token volume projection에 대해서 살펴보았습니다. 핵심은 projected service account token은 기본 service account token과 다르게 audience나 만료기간 등의 추가적인 정보를 삽입할 수 있으며 ...</p></div></div></a></div><div class="card"> <a href="/posts/admission_webhook/"><div class="card-body"> <span class="timeago small" >Sep 13, 2022<i class="unloaded">2022-09-13T23:25:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook</h3><div class="text-muted small"><p> IRSA(IAM Role for Service Account)는 AWS EKS에서 파드 단위로 권한을 관리하기 위한 방법 또는 프로세스입니다. 요즘에 회사에서 kubeflow를 셋팅하고 있는데 AWS의 특정 리소스(S3 등)와의 통신을 위해 파드에 일정 권한을 부여해야할 상황이 자주 발생합니다. 저는 이때 주로 IRSA를 활용하여 업무를 진행하고 있습...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/OAuth/" class="btn btn-outline-primary" prompt="Older"><p>IRSA의 원리를 파헤쳐보자 3 - OAuth2.0</p></a> <a href="/posts/tsne/" class="btn btn-outline-primary" prompt="Newer"><p>T-SNE 이해하기</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/gguguk">Gukwon Koo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/retrospective/">retrospective</a> <a class="post-tag" href="/tags/k8s/">k8s</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/nlp/">nlp</a> <a class="post-tag" href="/tags/statistics/">statistics</a> <a class="post-tag" href="/tags/irsa/">irsa</a> <a class="post-tag" href="/tags/ml/">ml</a> <a class="post-tag" href="/tags/mlops/">mlops</a> <a class="post-tag" href="/tags/paper/">paper</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://gguguk.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-8EWVG7CHCY"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-8EWVG7CHCY'); }); </script>

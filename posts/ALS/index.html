<!DOCTYPE html><html lang="en" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Expires" content="0"><meta http-equiv="Pragma" content="no-cache"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="‘Collaborative Filtering for Implicit Feedback Datasets(ALS)’ 논문 리뷰" /><meta name="author" content="Gukwon Koo" /><meta property="og:locale" content="en" /><meta name="description" content="ALS는 행렬 분해를 활용한 대표적인 추천 알고리즘입니다." /><meta property="og:description" content="ALS는 행렬 분해를 활용한 대표적인 추천 알고리즘입니다." /><link rel="canonical" href="https://gguguk.github.io/posts/ALS/" /><meta property="og:url" content="https://gguguk.github.io/posts/ALS/" /><meta property="og:site_name" content="생각과 고민." /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-30T22:31:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="‘Collaborative Filtering for Implicit Feedback Datasets(ALS)’ 논문 리뷰" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Gukwon Koo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Gukwon Koo"},"dateModified":"2021-03-30T22:31:00+09:00","datePublished":"2021-03-30T22:31:00+09:00","description":"ALS는 행렬 분해를 활용한 대표적인 추천 알고리즘입니다.","headline":"‘Collaborative Filtering for Implicit Feedback Datasets(ALS)’ 논문 리뷰","mainEntityOfPage":{"@type":"WebPage","@id":"https://gguguk.github.io/posts/ALS/"},"url":"https://gguguk.github.io/posts/ALS/"}</script><title>'Collaborative Filtering for Implicit Feedback Datasets(ALS)' 논문 리뷰 | 생각과 고민.</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="생각과 고민."><meta name="application-name" content="생각과 고민."><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/sample/bear.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">생각과 고민.</a></div><div class="site-subtitle font-italic">주니어 데이터 사이언티스트입니다.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/gguguk" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/%EA%B5%AD%EC%9B%90-%EA%B5%AC-32a9691a1/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>'Collaborative Filtering for Implicit Feedback Datasets(ALS)' 논문 리뷰</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>'Collaborative Filtering for Implicit Feedback Datasets(ALS)' 논문 리뷰</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Gukwon Koo </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Mar 30, 2021, 10:31 PM +0900" >Mar 30, 2021<i class="unloaded">2021-03-30T22:31:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4813 words">26 min read</span></div></div><div class="post-content"><p><img data-proofer-ignore data-src="https://miro.medium.com/max/1540/1*ezY_g30VQ8MTGpDwd3z56w.png" alt="" /><em>ALS는 행렬 분해를 활용한 대표적인 추천 알고리즘입니다.</em></p><p><br /></p><p>추천 시스템을 구축하기 위한 첫 출발점으로는 matrix factorization에 기반을 둔 모델을 많이 활용합니다. 그 이유는 단일 모델로서 성능도 좋고, 무엇보다 데이터 파이프라인이 간단하고 서빙이 편리하기 때문이라고 생각합니다. matrix factorization 기법을 활용한 추천 모델은 매우 다양한데요. 대표적으로 SVD, SGD, ALS 등을 꼽을 수 있을 것 같습니다. 본 글에서는 ALS를 소개한 논문을 정리하고, 본 논문에서는 생략되어 있는 수식 유도 과정을 추가로 정리 하고자 합니다. 논문의 제목은 “<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.167.5120&amp;rep=rep1&amp;type=pdf">Collaborative Filtering for Implicit Feedback Datasets</a>” 입니다. 제목에서도 유추가 가능하지만 implicit data에 matrix factorization 기법을 어떻게 적용할지에 대한 간단한 아이디어를 제안한 논문입니다.</p><p><br /></p><p>본 글에서 행렬과 벡터의 표기는 다음을 따릅니다.</p><ul><li>행렬: \(\boldsymbol{X}\)<li>벡터: \(\boldsymbol{x}\)<li>벡터의 원소: \(x\)</ul><p><br /></p><h1 id="introduction">Introduction</h1><hr /><h2 id="characteristic-of-implicit-data">Characteristic of implicit data</h2><p>저자는 현실 세계의 문제는 대부분 implicit data로 구성되어 있으므로 implicit data를 활용한 추천 시스템 연구가 반드시 필요하다고 주장합니다. 특히 우리가 implicit data에 주목해야 하는 이유는 implicit data가 다음의 특성을 가지고 있기 때문입니다.</p><ul><li><p><strong>No negative feedback</strong></p><p>explicit data는 유저가 특정 아이템을 좋아하는지(like) 싫어하는지(dislike)를 명확하게 알 수 있고, 이러한 풍부한 정보를 활용하여 추천 시스템을 모델링 할 수 있습니다. 저자의 표현을 빌리면 유저의 선호에 대한 balanced picture를 활용할 수 있다는 것입니다. 그러나 implicit data는 유저가 특정 아이템과 interaction이 있었는지 없었는지 여부만 알 수 있습니다. 예를 들어 어떤 유저가 유튜브에서 무한도전 영상을 보지 않았다면, 무한도전 영상을 싫어해서 보지 않은 것인지 그 영상의 존재 여부를 몰라서 그런 것인지를 추측하기가 어렵다는 것이죠.</p><p>또한 explicit data나 implicit data 모두 user-rating 행렬의 대부분의 값들이 missing value로서 존재합니다. 일반적으로 explicit data로 추천 시스템 모델링을 할 때는 missing value를 탈락시키고 관측된 데이터로만 모델링을 진행합니다. explicit data는 관측된 데이터 안에서도 선호 또는 비선호 정보가 모두 있기 때문에 논리적인 비약이 발생하지 않습니다. 그러나 implicit data의 경우 missing value를 탈락 시킨후 모델링을 진행하면 positive feedback 정보만 활용하여 모델링을 진행하게 되는 꼴이 되버립니다. 저자는 이를 ‘misrepresenting the full user profile’이라고 표현하였습니다.</p><li><p><strong>Implicit feedback is inherently noisy</strong></p><p>우리는 유저의 implicit feedbac을 통해 정확한 유저의 선호를 알 수 없습니다. 제가 인터넷에서 코트 한벌을 구입 했다고 가정해볼게요. 물론 심사숙고 끝에 코트를 구입한 것이므로, 구매 행위는 positive feedback이라고 생각할 수도 있습니다. 그러나 만일 제가 코트를 받아보고 원단 재질에 실망 했다면 구매 행위가 negative feedback이 될 수 있는 여지도 있죠. 비슷하게 어떤 유저의 영상 시청 시간이 길다는 것이 무조건 positive feedback은 아닐 것입니다. 영상을 틀어 놓고 잠이 들었을 수도 있는 것이죠.</p><li><p><strong>Numerical value of implicit feedback indicates <em>confidence</em></strong></p><p>explicit feedback은 유저의 <em>preference</em>를 나타내지만, implicit feedback은 단순히 <em>frequency of actions</em>를 나타냅니다. 다시 말해, implicit data에서는 특정 행위의 빈도가 높다는 것이 유저가 그 아이템을 선호한다는 것을 의미하지 않는다는 것입니다. 예를 저는 가장 좋아하는 가수가 임창정인데요. 그렇다고 해서 하루에 몇 백번씩 소주 한잔을 듣지는 않습니다.</p><p>그러나 implicit feedback의 빈도가 전혀 유용하지 않다는 의미는 아닙니다. 특정 행위가 계속해서 반복 된다는 것은 특정 유저의 opinion을 반영한다는 의미가 될 수 있습니다. 정리하자면, implicit feedback의 빈도가 높다는 것은 유저가 그 아이템을 선호한다고 단정지어 말할 수는 없지만, 적어도 선호할 것이라고 주장하는 것에 대한 신뢰도(confidence)를 높여줄 수 있습니다.</p></ul><p><br /></p><h2 id="objective">Objective</h2><p>이러한 implicit data의 특징을 알아 두시구요. 계속해서 다음의 두가지 논의를 중점적으로 살펴보겠습니다.</p><ul><li>implicit data에서 confidence를 어떻게 계산할 것인가?<ul><li>\(C_{ui}\) 지표 제안</ul><li>효율적인 추천 시스템을 어떻게 구현할까?<ul><li>ALS(Alternative Least Square) 제안</ul></ul><p><br /></p><h1 id="latent-factor-collaborative-filtering">Latent factor collaborative filtering</h1><hr /><p>추천 시스템을 구현하는 방식은 매우 다양합니다. 간단하게는 아이템 자체의 정보(e.g. 상품명)만을 이용하여 유사한 아이템을 추천하는 contents-based 추천 알고리즘이 있습니다. TF-IDF나 word2vec 기반의 추천 시스템이 대표적인 예시입니다.</p><p>한편 CF(collaborative filtering) 방식으로 추천 시스템을 구현할 수도 있습니다. CF는 유저와 아이템간의 interdependency를 분석하여 새로운 user-item 관계를 발견하기 위한 기법입니다. 쉽게 풀어쓰면 단순히 상품 자체의 정보만을 이용하는 것이 아니라 비슷한 다른 유저의 interaction 정보를 활용하여 유저와 아이템간의 내재된 관계를 발견해보겠다는 것입니다.</p><p>당연하게도 CF 기반의 추천 시스템을 구현하는 다양한 방법이 존재합니다. 그 중에서 Netflix Prize Competition에서 우수한 성적을 거둔 matrix factorization 기반의 추천 알고리즘이 많이 활용됩니다. 다른 말로 latent factor CF라고도 불립니다. 행렬 분해를 활용한 추천 시스템의 핵심은 유저와 아이템을 특정 차원의 latent factor로 잘 임베딩하는 방법을 찾는 것입니다. 아래의 그림을 통해 조금 더 자세히 설명해볼게요.</p><p><br /></p><p><img data-proofer-ignore data-src="https://miro.medium.com/max/1800/0*-b5Kq3UnRfDWHZj3.png" alt="" /></p><p><br /></p><p>latent factor CF 알고리즘은 기본적으로 user-item 행렬 \(\boldsymbol{R} \in \mathbb{R}^{n \times m}\)을 유저 행렬 \(\boldsymbol{U}\in \mathbb{R}^{n \times k}\)와 아이템 행렬 \(\boldsymbol{V} \in \mathbb{R}^{m \times k}\)로 분해해서 표현하는 것입니다. 유저 행렬 \(\boldsymbol{U}\)와 아이템 행렬 \(\boldsymbol{V}^T\)를 곱하면 원 행렬과 똑같은 크기의 행렬로 복원할 수 있는데요. 이 행렬을 \(\hat{\boldsymbol{R}} = \boldsymbol{U}\boldsymbol{V}^T\)이라고 한다면 <strong>latent factor CF의 핵심은 \(\boldsymbol{R}\)과 \(\hat{\boldsymbol{R}}\)의 차이를 최대한 줄이는 것이 핵심</strong>이겠죠. latent factor CF를 구현하는 대표적인 알고리즘으로 SVD, SGD, ALS 등을 들 수 있는데요. 본 논문에서는 <strong>ALS</strong>를 다룹니다.</p><p><br /></p><h1 id="notations">Notations</h1><hr /><p>앞으로의 논의에는 많은 notation이 등장하는데요. 이에 대해 정리를 하고 가는 것이 좋을 것 같습니다. 특히 논문에 행렬 notation이 매우 헷갈릴만하게 서술 되어 있기 때문에 행렬 형상을 주의해서 살펴주시길 바랍니다.</p><ul><li>\(m\) : 유저의 개수<li>\(n\) : 아이템의 개수<li><p>\(f\) : 유저와 아이템 latent vector의 차원수</p><li>\(\boldsymbol{X} \in \mathbb{R}^{m \times f}\) : \(m\)명의 유저의 latent vector \(\boldsymbol{x}_u\)를 행벡터 \(\boldsymbol{x}_u^{T}\)로 쌓은 유저 행렬.<li>\(\boldsymbol{Y} \in \mathbb{R}^{n \times f}\) : \(n\)개의 아이템의 latent vector \(\boldsymbol{y}_i\)를 행벡터 \(\boldsymbol{y}_i^{T}\)로 쌓은 아이템 행렬.<li>\(\boldsymbol{x}_u \in \mathbb{R}^f\) : 유저 \(u\)의 latent vector (열벡터)<li>\(\boldsymbol{y}_i \in \mathbb{R}^f\) : 아이템 \(i\)의 latent vector (열벡터)<li>\(\boldsymbol{p(u)} \in \mathbb{R}^n \): 유저 \(u\)의 \(n\)개의 아이템에 대한 preference \(p_{ui}\)를 나타내는 벡터<li>\(\boldsymbol{C^u} \in \mathbb{R}^{n \times n} \): 유저 \(u\)의 \(n\)개의 아이템에 대한 confidence \(c_{ui}\)를 나타내는 대각 행렬<li>\(r_{ui}\) : 유저 \(u\)의 아이템 \(i\)에 대한 observations (e.g. 구매 횟수, 시청 시간)<li>\(\hat{r}_{ui}\) : 유저 \(u\)의 아이템 \(i\)에 대한 예측 observations</ul><p><br /></p><h1 id="our-model">Our model</h1><hr /><p>본 논문에서 저자가 주장하는 핵심은 다음의 두가지입니다. 섹션 4에서는 계속해서 두 핵심 주장을 좀더 자세히 살펴보겠습니다. 논문에는 자세한 설명이 생략되어 있어서 저의 개인적인 의견을 덧붙여서 설명드려 보겠습니다.</p><ul><li>implicit data의 특성에 기반하여 raw observations \(\boldsymbol{r_{ui}}\)를 preference \(\boldsymbol{p_{ui}}\)와 confidence level \(\boldsymbol{c_{ui}}\)로 변환하여 활용<li>global mininum으로의 수렴이 보장되는 <strong>ALS</strong>(Alternative Least Square) 알고리즘 제안</ul><p><br /></p><h2 id="preference">preference</h2><p>저자는 먼저 유저 \(u\)가 아이템 \(i\)에 대해 intercation이 한번이라도 있었으면 \(p_{ui}=1\)로, interaction이 없었으면 \(p_{ui}=0\)으로 binarizing을 합니다.</p><p><br /></p>\[p_{ui} = \begin{cases} 1 &amp; r_{ui}&gt;0 \\ 0 &amp; r_{ui}=0 \end{cases}\]<p><br /></p><p>일단은 interaction이 있었다는 것을 유저가 아이템을 like 한다는 징후(indication)으로 가정합니다. 반대로 말하면 interaction이 없었다는 것은 유저가 해당 아이템을 선호하지 않는다고 가정하는 것이죠. 그러나 이러한 가정은 어딘가 부족해보입니다. 당장 저자가 언급하였던 implicit data의 내재적 문제를 전혀 고려하지 못한 주장이라는 생각이 듭니다. 따라서 저자는 이를 보완하고자 confidence level이라는 지표를 추가적으로 도입합니다.</p><p><br /></p><h2 id="confidence-level">confidence level</h2><p>confidence level이란 \(p_{ui}={0, 1}\) 값의 신뢰도(confidence level)를 정량화하기 위한 지표입니다. \(p_{ui}=0\)인 이유는 정말 여러가지가 있을 수 있습니다. 예를 들어서 실제로 아이템 \(i\)가 존재한다는 것을 알고 있으면서도 해당 아이템을 선호하지 않기 때문에 interaction을 하지 않았을 수도 있습니다. 이 경우는 실제로 negative feedback이죠. 그러나 유저가 아이템 \(i\)의 존재를 몰랐을 수도 있으며, 아이템 \(i\)의 비싼 가격 때문에 선호를 함에도 불구하고 interaction을 하지 않았을 수도 있죠. 따라서 interaction이 없었다는 사실 하나만으로 선호/비선호를 이분법적으로 구분하는 것은 논리적 비약입니다. 따라서 저자는 \(p_{ui}\)의 confidence level를 측정하기 위한 지표를 제안합니다.</p><p><br /></p>\[c_{ui} = 1 + \alpha r_{ui}\]<p><br /></p><p>먼저 이 지표를 설명하기 위한 가정 하나가 있습니다. 바로 \(r_{ui}\)값이 증가할수록 유저 \(u\)가 아이템 \(i\)를 더욱 강하게 선호한다는 것입니다. 단순히 interaction이 있었다면 선호, 없었다면 비선호 한다는 가정보다는 훨씬 납득할만한 가정이라고 생각합니다.</p><p>이제 신뢰도 지표 \(c_{ui}\)를 도입한 저자의 목적을 이해해 봅시다. 신뢰도 지표 \(c_{ui}\)는 똑같이 \(p_{ui}=1\)를 가지는 user-item 쌍에 대해서도 \(r_{ui}\)에 따른 가중치를 달리 줄 수 있다는 점에서 중요한 지표라고 생각합니다. 예를 들어 \(r_{ui}\)를 유저 \(u\)가 아이템 \(i\)를 구매한 횟수라고 한다면, \(r_{ui}=1\)인 것에 비해 \(r_{ui}=10000\)인 것이 유저 \(u\)의 아이템 \(i\)에 대한 선호도가 강하다고 상식적으로 생각할 수 있습니다.</p><p>그러나 \(c_{ui}\)를 고려하지 않는다면 \(r_{ui}=1\)인 것이나 \(r_{ui}=10000\) 모두 \(p_{ui}=1\)로 동일한 값을 갖게 되므로 선호의 강도의 차이를 반영하지 못하게 됩니다. 다시 \(c_{ui}\)를 계산하는 수식을 살펴봅시다. \(r_{ui}\)가 증가할수록 confidence level \(c_{ui}\)가 선형적으로 증가하게 됨을 확인하실 수 있습니다. 다시 말해 <strong>confidence level \(c_{ui}\) 지표를 도입함에 따라 ‘선호의 강도’를 구분할 수 있게 된 것</strong>입니다. 참고로 저자는 실험적으로 \(\alpha=40\)이 좋았다고는 하는데, 절대적인 진리는 아니라고 생각합니다. 참고용으로만 알아두시면 될 것 같습니다.</p><p><br /></p><h2 id="als">ALS</h2><p>이제 저자의 두번째 핵심 주장인 ALS 알고리즘에 대해 살펴보겠습니다. ALS는 matrix factorization 기반의 알고리즘인데요. 따라서 아래의 수식이 ALS 알고리즘의 최적화 목표입니다.</p><p><br /></p>\[\min_{\boldsymbol{x}*,\boldsymbol{y}*}\sum_{u, i}c_{ui}(p_{ui} - \boldsymbol{x}_{u}^{T}\boldsymbol{y}_{i})^{2} + \lambda \bigg( \sum_{u} \|\boldsymbol{x}_{u}\|^{2} + \sum_{i} \|\boldsymbol{y}_{i}\|^{2} \bigg) \tag{1}\]<p><br /></p><p>먼저 \(\lambda \big( \sum_{u} \|\boldsymbol{x}_{u}\|^{2} + \sum_{i} \|\boldsymbol{y}_{i}\|^{2} \big)\)는 알고리즘의 overfitting을 방지하기 위한 일반적인 regularizing term입니다. 중요한 점은 \((1)\) 수식은 모든 유저-아이템 쌍 \(m \times n\)에 대해서 계산된다는 점입니다. 따라서 데이터 셋의 크기가 매우 크다면(\(m \times n\)이 매우 큰 숫자라면) explicit data 최적화에 주로 활용되는 SGD 등의 최적화 테크닉은 잘 작동하지 않는다고 합니다. 따라서 저자는 이러한 현실적인 문제를 극복하기 위해 효율적인 최적화 테크닉인 ALS(alternative least square)를 제안합니다.</p><p>ALS는 이름에서도 알 수 있듯이 <strong>번갈아가며</strong> 최적화를 진행한다는 것입니다. <strong>무엇</strong>을 번갈아가며 최적화를 한다는 것일까요? 바로 유저 행렬 \(\boldsymbol{X}\)와 아이템 행렬 \(\boldsymbol{Y}\)입니다. 그렇다면 <strong>어떻게</strong> 최적화를 한다는 것일까요? 다음의 순서에 따라 최적화를 진행합니다.</p><ul><li>Step1: 아이템 행렬 \(\boldsymbol{Y}\)를 상수로 고정하고, 유저 행렬 \(\boldsymbol{X}\)를 최적화<li>Step2: 유저 행렬 \(\boldsymbol{X}\)를 상수로 고정하고, 아이템 행렬 \(\boldsymbol{Y}\)를 최적화<li>Step3: Step1과 Step2를 원하는 횟수만큼 반복</ul><p><br /></p><p>이러한 방식의 최적화는 OLS에서 residual이 최소화되는 파라미터를 찾는 방법과 정확히 일치합니다. OLS는 global minum 값이 항상 보장되는 convex function이라고 합니다. 따라서 학습 프로세스가 진행됨에 따라 cost가 지속적으로 감소되는 것이 보장된다고 합니다. 사실 수식 \((1)\)을 최소화하는 최적의 \(\boldsymbol{x_u}\)는 다음의 solution으로 결정되어 있습니다. \(\boldsymbol{x}_u\)를 유도하는 수식은 Appendix에 자세히 적어 두겠습니다. 혹시 궁금하신 분들은 참고해주세요.</p><p><br /></p>\[\boldsymbol{x}_u = (\boldsymbol{Y}^T\boldsymbol{C}^{u}\boldsymbol{Y}+ \lambda\boldsymbol{I})^{-1}\boldsymbol{Y}^T\boldsymbol{C}^{u}\boldsymbol{p(u)} \tag{2}\]<p><br /></p><p>같은 방법으로 최적의 \(\boldsymbol{y}_i\)의 solution을 도출할 수 있습니다.</p><p><br /></p>\[\boldsymbol{y}_i = (\boldsymbol{X}^T\boldsymbol{C}^{i}\boldsymbol{X}+ \lambda\boldsymbol{I})^{-1}\boldsymbol{X}^T\boldsymbol{C}^{i}\boldsymbol{p(i)} \tag{3}\]<p><br /></p><p>이제 우리는 최적의 \(\boldsymbol{x}_u\)와 \(\boldsymbol{y}_i\)를 원하는 횟수만큼 번갈아서 계산하면 되겠습니다.</p><p><br /></p><h1 id="맺으며">맺으며</h1><p>본 논문에서 저자의 핵심 주장은 다음의 두가지입니다.</p><ul><li>implicit data에서 preference 지표와 confidence level 지표를 도입<li>효율적인 행렬 최적화를 위한 ALS 제안</ul><p>개인적으로는 대표적인 행렬 분해 추천 알고리즘인 ALS가 따로 논문이 존재한다는 것을 처음 알게 되었는데요. 새롭고 혁신적인 주장은 의외로 간단한 아이디어에서 시작하는 것 같습니다. 특히 행렬 분해를 OLS 방식으로 해결하는 시도가 매우 인상 깊었습니다. 그러나 이 방법도 한계가 존재한다고 생각합니다. 저는 일반적인 CF 기법과 마찬가지로 다양한 feature를 반영하지 못한다는 점을 지적하고 싶습니다. 논문을 읽어 보시면 아시겠지만 TV 시청시간, 제품 구매 횟수 등 단편적인 feature만을 예시로 계속 들고 있습니다. 이러한 단점 때문에 최근에는 다양한 feature를 구성할 수 있는 FM(Factorization Machine)이나 딥러닝 기반 추천을 도입하려는 시도가 많이 이루어지는 것 같습니다. 다음 번 추천 시스템 포스팅은 FM이나 딥러닝 기반 추천 알고리즘에 대해 다뤄보려고 합니다. 긴 글 읽어 주셔서 감사합니다.</p><p><br /></p><h1 id="appendix">Appendix</h1><hr /><h2 id="step1-l을-boldsymbolx_u로-편미분한-값을-구해봅시다">Step1. \(L\)을 \(\boldsymbol{x}_u\)로 편미분한 값을 구해봅시다.</h2><p><br /></p>\[\begin{align} \cfrac{\partial L}{\partial \boldsymbol{x}_u} &amp;= \cfrac{\partial}{\partial \boldsymbol{x}_u}\bigg[\sum_{i}c_{ui}(p_{ui}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_i)^2 + \lambda \big( \sum_{u} \|\boldsymbol{x}_{u}\|^{2} + \sum_{i} \|\boldsymbol{y}_{i}\|^{2} \big) \bigg] \\[1em] &amp;= \cfrac{\partial}{\partial \boldsymbol{x}_u}\bigg[\sum_{i}c_{ui}(p_{ui}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_i)^2 \bigg] + \cfrac{\partial}{\partial \boldsymbol{x}_u} \bigg[\lambda \big( \sum_{u} \|\boldsymbol{x}_{u}\|^{2} + \sum_{i} \|\boldsymbol{y}_{i}\|^{2} \big) \bigg] \\[1em] &amp;= \begin{bmatrix} \cfrac{\partial}{\partial x_{u1}}\bigg[\sum_{i}c_{ui}(p_{ui}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_i)^2 \bigg] \\ \vdots\\ \cfrac{\partial}{\partial x_{uf}}\bigg[ \sum_{i}c_{ui}(p_{ui}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_i)^2 \bigg] \end{bmatrix} + \cfrac{\partial}{\partial \boldsymbol{x}_u} \bigg(\lambda \sum_{u} \|\boldsymbol{x}_{u}\|^{2} \bigg) + \cfrac{\partial}{\partial x_{u}} \bigg(\lambda \sum_{i} \|\boldsymbol{y}_{i}\|^{2} \big) \bigg) \\[1em] &amp;= \begin{bmatrix} \cfrac{\partial}{\partial x_{u1}}\bigg[\sum_{i}c_{ui}(p_{ui}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_i)^2 \bigg] \\ \vdots\\ \cfrac{\partial}{\partial x_{uf}}\bigg[ \sum_{i}c_{ui}(p_{ui}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_i)^2 \bigg] \end{bmatrix} + \cfrac{\partial}{\partial \boldsymbol{x}_u} \bigg(\lambda \sum_{u} \|\boldsymbol{x}_{u}\|^{2} \bigg) \\[1em] &amp;= \begin{bmatrix} \cfrac{\partial}{\partial x_{u1}}\bigg[c_{u1}(p_{u1}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_1)^2 + \cdots + c_{ui}(p_{ui}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_i)^2 + \cdots + c_{un}(p_{un}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_n)^2 \bigg] \\ \vdots\\ \cfrac{\partial}{\partial x_{uf}}\bigg[c_{u1}(p_{u1}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_1)^2 + \cdots + c_{ui}(p_{ui}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_i)^2 + \cdots + c_{un}(p_{un}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_n)^2 \bigg] \end{bmatrix} + \begin{bmatrix} \cfrac{\partial}{\partial x_{u1}} \bigg[ \lambda(x_{u1}^2 + \cdots + x_{uf}^2) \bigg] \\ \vdots \\ \cfrac{\partial}{\partial x_{uf}}\bigg[ \lambda(x_{u1}^2 + \cdots + x_{uf}^2) \bigg] \end{bmatrix} \\[1em] &amp;= \begin{bmatrix} -2c_{u1}(p_{u1}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_1)y_{11} - \cdots -2c_{ui}(p_{ui}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_i)y_{i1} - \cdots -2c_{un}(p_{un}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_n)y_{n1}\\ \vdots\\ -2c_{u1}(p_{u1}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_1)y_{1f} - \cdots -2c_{ui}(p_{ui}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_i)y_{if} - \cdots -2c_{un}(p_{un}-\boldsymbol{x}_{u}^{T}\boldsymbol{y}_n)y_{nf} \end{bmatrix} + 2\lambda \boldsymbol{x}_u \\[1em] &amp;= \begin{bmatrix} -2c_{u1}(p_{u1}-\boldsymbol{x}_{u}^T\boldsymbol{y}_{1})y_{11} \\ \vdots \\-2c_{u1}(p_{u1}-\boldsymbol{x}_{u}^T\boldsymbol{y}_{1})y_{1f} \end{bmatrix} + \cdots + \begin{bmatrix} -2c_{ui}(p_{ui}-\boldsymbol{x}_{u}^T\boldsymbol{y}_{i})y_{i1} \\ \vdots \\-2c_{ui}(p_{ui}-\boldsymbol{x}_{u}^T\boldsymbol{y}_{i})y_{if} \end{bmatrix} + \cdots + \begin{bmatrix} -2c_{un}(p_{un}-\boldsymbol{x}_{u}^T\boldsymbol{y}_{n})y_{n1} \\ \vdots \\ -2c_{un}(p_{un}-\boldsymbol{x}_{u}^T\boldsymbol{y}_{n})y_{nf} \end{bmatrix} + 2\lambda\boldsymbol{x}_u \\[1em] &amp;= -2c_{u1}(p_{u1}-\boldsymbol{x}_{u}^T \boldsymbol{y}_{1}) \boldsymbol{y}_{1} + \cdots + -2c_{ui}(p_{ui}-\boldsymbol{x}_{u}^T \boldsymbol{y}_{i})\boldsymbol{y}_{i} + \cdots + -2c_{un}(p_{un}-\boldsymbol{x}_{u}^T \boldsymbol{y}_{n})\boldsymbol{y}_{n}\\[1em] &amp;= -2\sum_{i}c_{ui}(p_{ui}-\boldsymbol{x}_{u}^T\boldsymbol{y}_i)\boldsymbol{y}_i + 2\lambda \boldsymbol{x}_u \end{align}\]<p><br /></p><h2 id="step2-편미분-값을-0으로-놓고-수식을-전개">Step2. 편미분 값을 0으로 놓고 수식을 전개</h2><p>먼저 편미분 값 = 0으로 놓은 수식을 적어볼게요.</p><p><br /></p>\[-2\sum_{i}c_{ui}(p_{ui}-\boldsymbol{x}_{u}^T\boldsymbol{y}_i)\boldsymbol{y}_i + 2\lambda \boldsymbol{x}_u = 0\]<p><br /></p><p>\(c_{ui}\)를 전개해 줍니다.</p><p><br /></p>\[-2\sum_{i}(c_{ui}p_{ui}-c_{ui}\boldsymbol{x}_{u}^T\boldsymbol{y}_i)\boldsymbol{y}_i + 2\lambda \boldsymbol{x}_u = 0\]<p><br /></p><p>\(\boldsymbol{y_i}\)를 전개해 줍니다.</p><p><br /></p>\[-2\sum_{i}c_{ui}p_{ui}\boldsymbol{y}_i+2\sum_{i}c_{ui}\boldsymbol{x}_{u}^T\boldsymbol{y}_i\boldsymbol{y}_i + 2\lambda \boldsymbol{x}_u = 0\]<p><br /></p><p>상수 \(2\)를 소거하고 식을 정리해 줍니다.</p><p><br /></p>\[\sum_{i}c_{ui}(\boldsymbol{x}_{u}^T\boldsymbol{y}_i)\boldsymbol{y}_i +\lambda \boldsymbol{x}_u = \sum_{i}c_{ui}p_{ui}\boldsymbol{y}_i\]<p><br /></p><p>\(\boldsymbol{x}_u^T\boldsymbol{y}_i\)는 상수이므로 \(\boldsymbol{x}_u^T\boldsymbol{y}_i = \boldsymbol{y}_i^T\boldsymbol{x}_u\)입니다.</p><p><br /></p>\[\sum_{i}c_{ui}(\boldsymbol{y}_i^T\boldsymbol{x}_{u})\boldsymbol{y}_i +\lambda \boldsymbol{x}_u = \sum_{i}c_{ui}p_{ui}\boldsymbol{y}_i\]<p><br /></p><p>\(\boldsymbol{y}_i^T\boldsymbol{x}_u\)는 상수이므로 \(\boldsymbol{y}_i\)와 자리를 바꿔도 무방합니다.</p><p><br /></p>\[\sum_{i}c_{ui}\boldsymbol{y}_i\boldsymbol{y}_i^T\boldsymbol{x}_{u} +\lambda \boldsymbol{x}_u = \sum_{i}c_{ui}p_{ui}\boldsymbol{y}_i\]<p><br /></p><p>\(\boldsymbol{x}_u\)를 \(\sum\) 밖으로 꺼냅니다.</p><p><br /></p>\[\boldsymbol{x}_{u}\sum_{i}c_{ui}\boldsymbol{y}_i\boldsymbol{y}_i^T +\lambda \boldsymbol{x}_u = \sum_{i}c_{ui}p_{ui}\boldsymbol{y}_i\]<p><br /></p><p>좌항을 \(\boldsymbol{x}_u\)로 묶습니다.</p><p><br /></p>\[(\sum_{i}c_{ui}\boldsymbol{y}_i\boldsymbol{y}_i^T +\lambda I) \boldsymbol{x}_u = \sum_{i}c_{ui}p_{ui}\boldsymbol{y}_i\]<p><br /></p><p>해당 수식을 행렬 notation으로 표현하면,</p><p><br /></p>\[(\boldsymbol{Y}\boldsymbol{C}^u\boldsymbol{Y}+\lambda I)\boldsymbol{x}_u = \boldsymbol{Y}^T\boldsymbol{C}^u\boldsymbol{P}(u)\]<p><br /></p><p>이제 마지막으로 양변에 \((\boldsymbol{Y}^T\boldsymbol{C}^u\boldsymbol{Y} + \lambda I)^{-1}\)을 곱해주면 solution을 얻을 수 있습니다.</p><p><br /></p>\[\boldsymbol{x}_u = (\boldsymbol{Y}^T\boldsymbol{C}^u\boldsymbol{Y} + \lambda I)^{-1} \boldsymbol{Y}^T \boldsymbol{C}^u \boldsymbol{P}(u)\]<p><br /></p><h1 id="reference">Reference</h1><hr /><ul><li><a href="https://sanghyukchun.github.io/31/">인터넷 속의 수학 - How Does Netflix Recommend Movies?</a><li><a href="https://sanghyukchun.github.io/73/">Machine Learning 스터디 (17) Recommendation System (Matrix Completion)</a><li><a href="https://yeo0.github.io/data/2019/02/23/Recommendation-System_Day8/">Matrix Factorization에 대해 이해, Alternating Least Square (ALS) 이해</a><li><a href="https://wikidocs.net/17206">모두를 위한 컨벡스 최적화</a><li><a href="https://en.wikipedia.org/wiki/Low-rank_approximation">Low-rank approximation</a><li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.167.5120&amp;rep=rep1&amp;type=pdf">Collaborative filtering for implicit feedback datasets</a><li><a href="https://towardsdatascience.com/alternating-least-square-for-implicit-dataset-with-code-8e7999277f4b">Alternating Least Square for Implicit Dataset with code</a></ul><p><br /></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/ml/'>ML</a>, <a href='/categories/paper-review/'>Paper Review</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/als/" class="post-tag no-text-decoration" >als</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text='Collaborative Filtering for Implicit Feedback Datasets(ALS)' 논문 리뷰 - 생각과 고민.&url=https://gguguk.github.io/posts/ALS/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title='Collaborative Filtering for Implicit Feedback Datasets(ALS)' 논문 리뷰 - 생각과 고민.&u=https://gguguk.github.io/posts/ALS/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text='Collaborative Filtering for Implicit Feedback Datasets(ALS)' 논문 리뷰 - 생각과 고민.&url=https://gguguk.github.io/posts/ALS/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/tsne/">T-SNE 이해하기</a><li><a href="/posts/how_to_work_python/">CS50 - 파이썬이 소스 코드를 실행하는 과정과 원리</a><li><a href="/posts/OIDC/">IRSA의 원리를 파헤쳐보자 4 - OIDC</a><li><a href="/posts/OAuth/">IRSA의 원리를 파헤쳐보자 3 - OAuth2.0</a><li><a href="/posts/admission_webhook/">IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/fasttext/"><div class="card-body"> <span class="timeago small" >Aug 16, 2020<i class="unloaded">2020-08-16T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Enriching Word Vectors with Subword Information</h3><div class="text-muted small"><p> Fasttext 논문(Enriching Word Vectors with Subword Information)을 리뷰해 보았습니다. 슬라이드쉐어에 동일한 내용을 업로드 하였으며, 슬라이드쉐어에서 보시려면 이곳을 확인해 주세요. 1   Introduction 2   General Model 3   Subwor...</p></div></div></a></div><div class="card"> <a href="/posts/attention_is_all_you_need/"><div class="card-body"> <span class="timeago small" >Oct 16, 2020<i class="unloaded">2020-10-16T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Attention Is All You Need</h3><div class="text-muted small"><p> “Attention Is All You Need” 논문을 읽은 후 관련 자료를 정리한 내용을 바탕으로 논문 리뷰를 진행 해보겠습니다. 서론 및 문헌연구는 제외하겠습니다. 1     Model Architecture transformer에서 가장 중요한 block은 self-attention과 point-wise feed forward net...</p></div></div></a></div><div class="card"> <a href="/posts/deep_learning_is_robust_to_massive_label_noise/"><div class="card-body"> <span class="timeago small" >Oct 20, 2020<i class="unloaded">2020-10-20T10:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Deep Learning is Robust to Massive Label Noise</h3><div class="text-muted small"><p> 현업의 데이터를 다루다보면 데이터에 noisy label이 많이 발생합니다. 가장 좋은 점은 일일이 수작업으로 data cleaning을 하는 것이 좋겠지만, 데이터의 양이 늘어남에 따라 라벨링을 교정하는 것 자체가 일이 되는 경우가 발생하게 됩니다. 이와 관련된 고민을 하던 중 noisy label이 모델에 끼치는 영향력을 분석한 논문을 발견하여 읽...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/SVD/" class="btn btn-outline-primary" prompt="Older"><p>특이값 분해(Singular Value Decompostion)</p></a> <a href="/posts/retrospective/" class="btn btn-outline-primary" prompt="Newer"><p>글또 5기 회고글</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/gguguk">Gukwon Koo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/retrospective/">retrospective</a> <a class="post-tag" href="/tags/k8s/">k8s</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/nlp/">nlp</a> <a class="post-tag" href="/tags/statistics/">statistics</a> <a class="post-tag" href="/tags/irsa/">irsa</a> <a class="post-tag" href="/tags/ml/">ml</a> <a class="post-tag" href="/tags/mlops/">mlops</a> <a class="post-tag" href="/tags/paper/">paper</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://gguguk.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-8EWVG7CHCY"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-8EWVG7CHCY'); }); </script>

<!DOCTYPE html><html lang="en" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Expires" content="0"><meta http-equiv="Pragma" content="no-cache"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="특이값 분해(Singular Value Decompostion)" /><meta name="author" content="Gukwon Koo" /><meta property="og:locale" content="en" /><meta name="description" content="행렬을 직교행렬 두개와 대각행렬 하나로 분해할 수 있습니다." /><meta property="og:description" content="행렬을 직교행렬 두개와 대각행렬 하나로 분해할 수 있습니다." /><link rel="canonical" href="https://gguguk.github.io/posts/SVD/" /><meta property="og:url" content="https://gguguk.github.io/posts/SVD/" /><meta property="og:site_name" content="생각과 고민." /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-07T22:19:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="특이값 분해(Singular Value Decompostion)" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Gukwon Koo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Gukwon Koo"},"dateModified":"2021-03-07T22:19:00+09:00","datePublished":"2021-03-07T22:19:00+09:00","description":"행렬을 직교행렬 두개와 대각행렬 하나로 분해할 수 있습니다.","headline":"특이값 분해(Singular Value Decompostion)","mainEntityOfPage":{"@type":"WebPage","@id":"https://gguguk.github.io/posts/SVD/"},"url":"https://gguguk.github.io/posts/SVD/"}</script><title>특이값 분해(Singular Value Decompostion) | 생각과 고민.</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="생각과 고민."><meta name="application-name" content="생각과 고민."><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/sample/bear.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">생각과 고민.</a></div><div class="site-subtitle font-italic">주니어 데이터 사이언티스트입니다.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/gguguk" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/%EA%B5%AD%EC%9B%90-%EA%B5%AC-32a9691a1/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>특이값 분해(Singular Value Decompostion)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>특이값 분해(Singular Value Decompostion)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Gukwon Koo </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Mar 7, 2021, 10:19 PM +0900" >Mar 7, 2021<i class="unloaded">2021-03-07T22:19:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3442 words">19 min read</span></div></div><div class="post-content"><p><img data-proofer-ignore data-src="/assets/img/post_img/svd.png" alt="" width="600" /><em>행렬을 직교행렬 두개와 대각행렬 하나로 분해할 수 있습니다.</em></p><p><br /></p><h3 id="3줄-요약">3줄 요약</h3><hr /><ul><li>특이값 분해(SVD)는 \(m \times n\) 직사각 행렬 \(M\)을 직교행렬 \(U\), \(V^T\)와 고유값 행렬 \(\Sigma\)로 대갹화 하는 방법입니다.<li>고유값 분해(EVD)는 정방 행렬에만 적용 가능한데 반해, 특이값 분해(SVD)는 직사각 행렬에도 적용가능 합니다.<li>데이터 압축, 노이즈 제거, 추천 시스템 등 머신러닝과 관련된 다양한 분야에서 응용되는 중요한 개념입니다.</ul><hr /><p><br /></p><p>\(m \times n\) 직사각 행렬을 직교 행렬 두개와 고유값 행렬로 대각화 할 수 있는 특이값 분해에 대해 알아보겠습니다. 특이값 분해는 직사각 행렬도 적용할 수 있다는 점에서 정방 행렬만을 대상으로 하는 <a href="https://gguguk.github.io/posts/eigenvalue_decomposition/">고유값 분해</a>에 비해 그 활용 범위가 넓다고 할 수 있습니다. 머신러닝을 공부하시는 분들이라면 한번쯤은 들어보셨을 것이라고 생각합니다. 머신러닝과 관련된 정말 여러 분야에서 활용되는 개념이므로 반드시 이해가 필요하다고 생각합니다. 특이값 분해를 이해하기 위해서는 아래의 선수 지식이 요구됩니다.</p><ul><li><a href="https://gguguk.github.io/posts/eigenvalue_eigenvector/">고유값과 고유벡터</a><li>대칭 행렬(symmetric matrix)<li>직교 행렬(orthogonal matrix)</ul><p><br /></p><p>본 글에서 행렬과 벡터의 표기는 다음을 따릅니다.</p><ul><li>행렬: \(\boldsymbol{X}\)<li>벡터: \(\boldsymbol{x}\)<li>벡터의 원소: \(x\)</ul><p><br /></p><h1 id="1--svd특이값-분해란">1   SVD(특이값 분해)란?</h1><hr /><p>특이값 분해(singular value decomposition)란 \(m \times n\) <strong>직사각</strong> 행렬을 아래와 같이 <strong>직교</strong> 행렬 두 개와 <strong>대각</strong> 행렬 하나로 대각화 분해하는 기법입니다.</p><p><br /></p>\[\boldsymbol{A} = \boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^{T} \tag{1}\]<p><br /></p><ul><li><p>\(\boldsymbol{U}\) : \(m \times m\) 정방 행렬</p><li><p>\(\boldsymbol{\Sigma}\): \(m \times n\) 직사각 대각 행렬</p><li><p>\(\boldsymbol{V}\): \(n \times n\) 정방 행렬</p></ul><p><br /></p><h1 id="2-boldsymbolu-행렬">2   \(\boldsymbol{U}\) 행렬</h1><hr /><p>\(\boldsymbol{U}\)는 \(\boldsymbol{A}\boldsymbol{A}^T\)를 고유값 분해(EVD)<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>하여 얻을 수 있는 고유 벡터(eigen vector)<sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>들을 열벡터로 가지는 <strong>직교 행렬</strong>(orthogonal matrix)<sup id="fnref:3"><a href="#fn:3" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>입니다. \(\boldsymbol{U}\)의 열벡터들은 직사각 행렬 \(\boldsymbol{A}\)의 left singular vector라고 불립니다. 그렇다면 \(\boldsymbol{U}\)가 어떻게 유도되는지 궁금하지 않으신가요? <a href="https://gguguk.github.io/posts/eigenvalue_decomposition/">대칭 행렬의 고유값 분해</a>의 성질을 활용하면 됩니다.</p><p><br /></p><p>대칭 행렬의 고유값 분해의 성질을 안다는 가정하에, \(\boldsymbol{A}\boldsymbol{A}^T\)를 통해서 \(\boldsymbol{U}\)를 유도해 보도록 하겠습니다. \(\boldsymbol{A}\boldsymbol{A}^T\)는 대칭 행렬이므로 항상 고유값 분해가 가능합니다 (심지어 직교 행렬로 분해가 가능). 따라서 \(\boldsymbol{A}\boldsymbol{A}^T\)를 고유값 분해하면, 아래와 같은 형태를 가질 것이라고 생각 할 수 있습니다.</p><p><br /></p>\[\boldsymbol{A}\boldsymbol{A}^T=\boldsymbol{MDM}^T \tag{2}\]<p><br /></p><ul><li>\(\boldsymbol{M}\), \(\boldsymbol{M}^T\): \(\boldsymbol{A}\boldsymbol{A}^T\)의 <strong>고유벡터</strong>들을 열벡터로 가지는 <strong>직교 행렬</strong><li>\(\boldsymbol{D}\): \(\boldsymbol{A}\boldsymbol{A}^T\)의 <strong>고유값</strong>들을 대각 원소로 가지는 <strong>대각 행렬</strong></ul><p><br /></p><p>그리고 위에서 언급한 \((1)\) 식을 활용해서 \(\boldsymbol{A}\boldsymbol{A}^T\)를 구해 보면 다음과 같이 수식을 전개할 수 있습니다.</p><p><br /></p>\[\begin{align} \boldsymbol{A}\boldsymbol{A}^T &amp;=\boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^{T}(\boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^{T})^T \\[1em] &amp;=\boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^{T} \boldsymbol{V} \boldsymbol{\Sigma}^T \boldsymbol{U}^T \\[1em] &amp;=\boldsymbol{U} (\boldsymbol{\Sigma}\boldsymbol{\Sigma}^T) \boldsymbol{U}^T \tag{3} \end{align}\]<p><br /></p><p>그렇다면, \((2)\) 식과 \((3)\) 식이 매우 비슷한 꼴이라는 것을 발견하셨나요? 이를 통해 처음에 유도하려고 했던 \(\boldsymbol{U}\)는 \(\boldsymbol{A}\boldsymbol{A}^T\)의 고유벡터들을 열벡터로 가지는 행렬이라는 것을 알 수 있네요!</p><p><br /></p><h1 id="3--boldsymbolv-행렬">3   \(\boldsymbol{V}\) 행렬</h1><hr /><p>\(\boldsymbol{V}^T\)는 \(\boldsymbol{A}^T\boldsymbol{A}\)를 고유값 분해(EVD)하여 얻을 수 있는 고유 벡터(eigen vector)들을 행벡터로 가지는 <strong>직교 행렬</strong>(orthogonal matrix)입니다. \(\boldsymbol{V}^T\)의 행벡터들은 직사각 행렬 \(\boldsymbol{A}\)의 right singular vector라고 불립니다.</p><p><br /></p><p>\(\boldsymbol{V}^T\)를 유도하는 것은 \(\boldsymbol{U}\)를 유도하는 과정과 사실상 거의 동일합니다. \(\boldsymbol{A}^T\boldsymbol{A}\)에 대해 고유값 분해를 한다는 점만 다릅니다(\(\boldsymbol{U}\)는 \(\boldsymbol{A}\boldsymbol{A}^T\)에 대한 고유값 분해였죠). 결과만 보면, \(\boldsymbol{A}^T\boldsymbol{A}\)를 고유값 분해하면 다음과 같은 식을 얻을 수 있습니다.</p><p><br /></p>\[\boldsymbol{A}^T\boldsymbol{A} = \boldsymbol{V}(\boldsymbol{\Sigma}^T\boldsymbol{\Sigma})\boldsymbol{V}^T \tag{4}\]<p><br /></p><p>다시 말해 \(\boldsymbol{V}^T\)는 \(\boldsymbol{A}^T\boldsymbol{A}\)의 고유벡터들을 행벡터로 가지는 행렬이라는 것을 알 수 있습니다.</p><p><br /></p><h1 id="4--boldsymbolsigma-행렬">4   \(\boldsymbol{\Sigma}\) 행렬</h1><hr /><p><img data-proofer-ignore data-src="https://cdn.askpython.com/wp-content/uploads/2020/11/SVD-1.jpg" alt="" width="600" /><em>\(m \gt n\) 일 때의 \(\Sigma\) 행렬의 형상. <a href="https://www.askpython.com/python/examples/singular-value-decomposition">AskPython</a></em></p><p><br /></p><p>\(\boldsymbol{\Sigma}\)는 \(\boldsymbol{A}\boldsymbol{A}^T\) 또는 \(\boldsymbol{A}^T\boldsymbol{A}\) 행렬의 <strong>고유값</strong>(eigen value)들의 <strong>제곱근</strong>(square root)으로 이루어진 \(m \times n\) <strong>직사각 대각 행렬</strong>입니다. \(\boldsymbol{A}\boldsymbol{A}^T\)와 \(\boldsymbol{A}^T\boldsymbol{A}\)는 공통의 고유값 \(\sigma^2_{1} \ge \sigma^{2}_2 \ge \cdots \ge \sigma^2_{r} \ge 0\) \((\)단, \(r = \text{min}(m, n)\)\()\)을 가집니다 (이유는 잠시 뒤에 나옵니다). 이들의 값에 루트를 씌워 얻은 \(\sigma \ge \sigma_2 \ge \cdots \ge \sigma_r \ge 0\)을 대각 원소로 가지는 \(m \times n\) 행렬이 바로 SVD에 찾으려는 \(\Sigma\) 행렬입니다. 그리고 이 행렬의 원소들을 singular value라고 합니다.</p><p><br /></p><p>왜 제곱근을 씌울까요? 먼저 대각 행렬 거듭제곱의 성질을 알아야 하겠습니다. 대각 행렬 자체를 \(n\) 제곱하는 것은 단순히 대각 성분들을 \(n\) 제곱한 것과 같은 결과입니다.</p><p><br /></p>\[D = \left[\begin{matrix} \sigma_{11} &amp; \cdots &amp; 0 \\ \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; \cdots &amp; \sigma_{mn} \end{matrix} \right] \text{일 때,}\]<p><br /></p>\[D^{n} = \left[\begin{matrix} \sigma_{11} &amp; \cdots &amp; 0 \\ \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; \cdots &amp; \sigma_{mn} \end{matrix} \right]^{n} = \left[\begin{matrix} \sigma_{11}^{n} &amp; \cdots &amp; 0 \\ \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; \cdots &amp; \sigma_{mn}^{n} \end{matrix} \right]\]<p><br /></p><p>다시 제곱근을 씌우는 이유를 설명해볼게요. \(\boldsymbol{A}\boldsymbol{A}^T\)와 \(\boldsymbol{A}^T\boldsymbol{A}\) 의 고유값으로 이루어진 행렬은 식 \((3)\)과 \((4)\)에서 보았듯이, 각각 \(\boldsymbol{\Sigma}\boldsymbol{\Sigma}^T\)와 \(\boldsymbol{\Sigma}^T\boldsymbol{\Sigma}\)입니다. 또한 특이값 분해의 정의에서 언급 했듯이, \(\boldsymbol{\Sigma}\)는 직사각 대각 행렬이므로 대각 행렬의 거듭 제곱 성질을 당연히 따르게 됩니다.</p><p><br /></p><p>최종적으로 \(\boldsymbol{\Sigma}\boldsymbol{\Sigma}^T\)와 \(\boldsymbol{\Sigma}^T\boldsymbol{\Sigma}\)는 \(\boldsymbol{\Sigma}^2\)과 같은 표현이라는 점을 알고 계시다면 (간단한 예시를 들어 계산 해보시면 쉽게 이해할 수 있어요), 우리가 알고 싶은 \(\boldsymbol{\Sigma}\) 행렬은 \(\boldsymbol{\Sigma}\boldsymbol{\Sigma}^T\) 또는 \(\boldsymbol{\Sigma}^T\boldsymbol{\Sigma}\)의 원소들의 제곱근(square root)임을 도출할 수 있겠습니다.</p><p><br /></p><h3 id="41--boldsymbolaboldsymbolat와-boldsymbolatboldsymbola의-고유값은-동일합니다">4.1   \(\boldsymbol{A}\boldsymbol{A}^T\)와 \(\boldsymbol{A}^T\boldsymbol{A}\)의 고유값은 동일합니다.</h3><p>\(\boldsymbol{A}\boldsymbol{A}^T\)의 고유값을 \(\lambda\)라고 하고 고유벡터를 \(\boldsymbol{v}(\neq \boldsymbol{0})\)라고 하면, 고유값과 고유벡터의 정의에 따라 아래 수식이 성립합니다.</p><p><br /></p>\[(\boldsymbol{A}\boldsymbol{A}^T)\boldsymbol{v} = \lambda \boldsymbol{v}\]<p><br /></p><p>양변에 \(\boldsymbol{A}^T\)를 곱하면 아래의 수식을 유도할 수 있습니다.</p>\[(\boldsymbol{A}^T\boldsymbol{A})(\boldsymbol{A}^T\boldsymbol{v}) = \lambda(\boldsymbol{A}^T \boldsymbol{v})\]<p><br /></p><p>위 수식을 볼때, \(\boldsymbol{A}\boldsymbol{A}^T\)과 \(\boldsymbol{A}^T\boldsymbol{A}\)의 고유값은 동일하다는 사실을 이끌어 낼 수 있습니다.</p><p><br /></p><h3 id="42--boldsymbolaboldsymbolat와-boldsymbolatboldsymbola의-고유값은-항상-0-이상의-값을-가집니다">4.2   \(\boldsymbol{A}\boldsymbol{A}^T\)와 \(\boldsymbol{A}^T\boldsymbol{A}\)의 고유값은 항상 0 이상의 값을 가집니다.</h3><p>이는 두가지 방식으로 증명할 수 있습니다. 그리 어렵지 않으니 꼭 천천히 읽어 봐주세요.</p><p><br /></p><p><strong>방법1.</strong> \(\boldsymbol{A}\boldsymbol{A}^T\)의 고유값을 \(\lambda\)라고 하고 고유벡터를 \(\boldsymbol{v}(\neq \boldsymbol{0})\)라고 하면, 고유값과 고유벡터의 정의에 따라 아래 수식이 성립합니다.</p><p><br /></p>\[\boldsymbol{A}\boldsymbol{A}^T\boldsymbol{v} = \lambda \boldsymbol{v}\]<p><br /></p><p>양변에 \(\boldsymbol{v}^T\)를 곱하면 아래의 수식을 유도할 수 있습니다.</p><p><br /></p>\[\begin{align} \boldsymbol{v}^T\boldsymbol{A}\boldsymbol{A}^T\boldsymbol{v} &amp;= \lambda \boldsymbol{v}^T \boldsymbol{v} \\[1em] (\boldsymbol{A}^T\boldsymbol{v})^T\boldsymbol{A}^T\boldsymbol{v} &amp;= \lambda \boldsymbol{v}^T \boldsymbol{v} \\[1em] \Vert \boldsymbol{A}^T\boldsymbol{v} \Vert^{2} &amp;= \lambda \Vert \boldsymbol{v} \Vert^{2} \end{align}\]<p><br /></p><p>\(\Vert \boldsymbol{A}^T\boldsymbol{v} \Vert^{2} \ge 0\) 이고, \(\Vert \boldsymbol{v} \Vert^{2} \gt 0\) \((\because \boldsymbol{v}\neq \boldsymbol{0})\)이므로 항상 \(\lambda \ge 0\) 임을 알 수 있습니다. 같은 과정을 \(\boldsymbol{A}^T\boldsymbol{A}\) 행렬에 적용해도 결국 고유값은 항상 0 이상이라는 동일한 결과를 얻을 수 있습니다.</p><p><br /></p><p><strong>방법 2.</strong> positive semi-definite matrix 행렬은 항상 0이상의 고유값을 가진다는 성질을 활용하여 증명 가능합니다. positive semi definite matrix는 대칭 행렬(symmetric matrix)에서만 정의 되는 개념인데요. 다음의 수식을 만족하는 대칭 행렬 \(\boldsymbol{A}\)를 positive semi-definite matrix라고 하며, positive semi-definite matrix는 항상 0 이상의 고유값을 가지는 성질이 있습니다.</p><p><br /></p>\[\forall \boldsymbol{x} \neq0, \space \boldsymbol{x}^T\boldsymbol{A}\boldsymbol{x} \ge0\]<p><br /></p><p>먼저 \(\boldsymbol{AA}^T\)와 \(\boldsymbol{A}^T\boldsymbol{A}\)가 대칭 행렬인지 알아보죠.</p><p><br /></p>\[(\boldsymbol{AA}^T)^T = \boldsymbol{A}\boldsymbol{A}^T\] \[(\boldsymbol{A}^T\boldsymbol{A})^T = \boldsymbol{A}^T\boldsymbol{A}\]<p><br /></p><p>대칭 행렬의 정의에 따라, 두 행렬은 대칭 행렬임을 알 수 있습니다. 그렇다면 positive semi-definite matrix 인지만 확인하면 고유값이 항상 0 이상이라는 사실을 알 수 있겠습니다.</p><p><br /></p>\[\boldsymbol{x}^T\boldsymbol{AA}^T\boldsymbol{x} = (\boldsymbol{A}^T\boldsymbol{x})^T(\boldsymbol{A}^T\boldsymbol{x}) \ge 0\] \[\boldsymbol{x}^T\boldsymbol{A}^T\boldsymbol{A}\boldsymbol{x} = (\boldsymbol{Ax})^T(\boldsymbol{Ax}) \ge 0\]<p><br /></p><p>따라서 \(\boldsymbol{AA}^T\)와 \(\boldsymbol{A}^T\boldsymbol{A}\)는 positive semi-definite 행렬임을 쉽게 알 수 있습니다. 이는 곧 \(\boldsymbol{AA}^T\)와 \(\boldsymbol{A}^T\boldsymbol{A}\)가 항상 0 이상의 고유값을 가진다는 사실을 증명한 것입니다.</p><p><br /></p><h1 id="5--reduced-svd">5   Reduced SVD</h1><hr /><p><img data-proofer-ignore data-src="/assets/img/post_img/reduced_svd.png" alt="" /><em>일부의 고유값만 취하여 원 행렬을 근사하는 행렬을 계산할 수 있습니다.</em></p><p><br /></p><p>사실 SVD는 행렬을 분해하는 과정 보다는 부분 정보만 활용하여 복원하는 과정에서 그 활용성이 빛나는 것 같습니다. 이와 같은 방법을 통해 데이터 압축, 노이즈 제거 등의 기법을 구현할 수 있게 됩니다. 특히 추천 시스템은 원 행렬의 크기가 커질수록 연산량이 기하급수적으로 증가하게 되는데, 일부의 정보 (일부의 고유값)만을 활용한다면 연산량을 획기적으로 낮춰서 원 행렬을 근사할 수 있게 됩니다. 물론 일부의 정보를 활용한다는 사실 때문에 원 행렬과 근사 행렬 간의 오차가 발생할 수는 있습니다.</p><p><br /></p><p>행렬을 복원은 일부의 값만 활용하여 다음과 같이 layer를 쌓는 것과 동일하게 생각해볼 수 있습니다. 먼저 행렬 \(\boldsymbol{A}(m \gt n)\)가 SVD를 거쳐 아래와 같이 분해 되었다고 생각해보죠. 지금까지는 위에서 언급한 일반적인 SVD와 관련된 내용입니다.</p><p><br /></p>\[\boldsymbol{A} = \boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{V}^T = \left[\begin{matrix} \vert &amp; &amp; \vert \\ \boldsymbol{u}_1 &amp; \cdots &amp; \boldsymbol{u}_{m} \\ \vert &amp; &amp; \vert \end{matrix} \right] \left[\begin{matrix} \sigma_{1} &amp; \cdots &amp; 0 \\ \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; \cdots &amp; \sigma_{n} \\ 0 &amp; \cdots &amp; 0 \end{matrix} \right] \left[\begin{matrix} - &amp; \boldsymbol{v}_{1}^{T} &amp;- \\ &amp; \vdots &amp; \\ - &amp; \boldsymbol{v}_{n}^{T} &amp;- \end{matrix} \right]\]<p><br /></p><p>그렇다면 어떻게 해야 원 행렬 \(\boldsymbol{A}\)와 같은 크기를 유지하면서도 ‘일부’의 정보만을 활용해서 연산량을 줄이는 방향으로 행렬 근사를 할 수 있을까요? \(\boldsymbol{U}\) 행렬과 \(\boldsymbol{V}^T\) 행렬을 건들면 원 행렬 \(\boldsymbol{A}\)와 크기가 달라져 버릴 것만 같습니다. 해결책은 \(\boldsymbol{\Sigma}\) 행렬의 크기를 조작하는 것입니다. 현재 \(\boldsymbol{\Sigma}\) 행렬에는 크기의 내림 차순으로 \(n\)개의 고유값이 대각 성분에 정렬되어 있는 상태입니다. 여기서 \(k(&lt;n)\)개의 고유값만 취해보는 것이죠. 이는 정보량이 큰 상위 \(k\)개의 값만 활용하는 것으로 해석 할 수 있습니다.</p><p><br /></p><p>본론으로 돌아와서 \(k\)개의 고유값만 활용하게 된다면 행렬 연산이 어떻게 변하는지 살펴봅시다.</p><p><br /></p>\[\boldsymbol{A}_k = \boldsymbol{U}_k\boldsymbol{\Sigma}_k\boldsymbol{V}^T_k = \left[\begin{matrix} \vert &amp; &amp; \vert \\ \boldsymbol{u}_1 &amp; \cdots &amp; \boldsymbol{u}_{k} \\ \vert &amp; &amp; \vert \end{matrix} \right] \left[\begin{matrix} \sigma_{1} &amp; \cdots &amp; 0 \\ \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; \cdots &amp; \sigma_{k} \end{matrix} \right] \left[\begin{matrix} - &amp; \boldsymbol{v}_{1}^{T} &amp;- \\ &amp; \vdots &amp; \\ - &amp; \boldsymbol{v}_{k}^{T} &amp;- \end{matrix} \right]\] \[\boldsymbol{A}_k \in \mathbb{R}^{m \times n}\] \[\boldsymbol{U}_k \in \mathbb{R}^{m \times k}\] \[\boldsymbol{\Sigma}_k \in \mathbb{R}^{k \times k}\] \[\boldsymbol{U}_k \in \mathbb{R}^{k \times n}\]<p><br /></p><p>이렇게 큰 정보량을 가지는 고유값 \(k\)개를 선택하여 근사 복원한 행렬 \(\boldsymbol{A}_k\)는 원 행렬 \(\boldsymbol{A}\)와 같은 크기를 유지하면서도, 연산량을 줄일 수 있는 이점이 있습니다. 물론 그 만큼의 정보의 손실을 발생한다는 단점이 있겠네요.</p><p><br /></p><p>마지막으로 SVD를 통해 분해된 행렬과 reduced SVD의 행렬 notation은 다음과 같이 덧셈 notation으로도 나타낼 수 있습니다.</p><p><br /></p>\[\boldsymbol{A} = \sigma_{1}\boldsymbol{u}_{1}\boldsymbol{v}^T_1 + \cdots + \sigma_{n}\boldsymbol{u}_{n}\boldsymbol{v}^T_{n}\] \[\boldsymbol{A}_k = \sigma_{1}\boldsymbol{u}_{1}\boldsymbol{v}^T_1 + \cdots + \sigma_{k}\boldsymbol{u}_{k}\boldsymbol{v}^T_{k}\]<p><br /></p><h1 id="reference">Reference</h1><hr /><ul><li><a href="https://www.oreilly.com/library/view/mastering-numerical-computing/9781788993357/9bc47734-34ba-4e13-a475-7f05d02f598a.xhtml">Singular-value decomposition, Orelly</a><li><a href="https://ko.wikipedia.org/wiki/%ED%8A%B9%EC%9E%87%EA%B0%92_%EB%B6%84%ED%95%B4">특잇값 분해, 위키피디아 한국어판</a><li><a href="https://en.wikipedia.org/wiki/Singular_value_decomposition">Singular value decomposition, wikipedia</a><li><a href="https://angeloyeo.github.io/2019/08/01/SVD.html">특이값 분해(SVD), 공돌이의 수학정리노트</a><li><a href="https://darkpgmr.tistory.com/106">특이값 분해(Singular Value Decomposition, SVD)의 활용, 다크 프로그래머</a><li><a href="https://rfriend.tistory.com/185">특이값 분해 (SVD, Singular Value Decomposition), R Friend</a><li><a href="https://m.blog.naver.com/PostView.nhn?blogId=tlaja&amp;logNo=220726154312&amp;proxyReferer=https:%2F%2Fwww.google.com%2F">선형대수학 - 특이값 분해 SVD(Singular Value Decomposition), 하루하루</a><li><a href="https://dowhati1.tistory.com/7">SVD (특이값 분해), 하고 싶은 일을 하자</a><li><a href="https://pasus.tistory.com/">특이값 분해(SVD)의 증명, Deep Campus</a><li><a href="https://math.berkeley.edu/~hutching/teach/54-2017/svd-notes.pdf">Notes on singular value decomposition for Math 54</a><li><a href="https://math.stackexchange.com/questions/1087064/non-zero-eigenvalues-of-aat-and-ata">Non-zero eigenvalues of \(\boldsymbol{AA}^T\) and \(\boldsymbol{A}^T \boldsymbol{A}\)</a><li><a href="https://data-science-hi.tistory.com/82">SVD 를 활용한 협업필터링</a><li>Vozalis, M. G., &amp; Margaritis, K. G. (2005, September). Applying SVD on item-based filtering. In <em>5th International Conference on Intelligent Systems Design and Applications (ISDA’05)</em> (pp. 464-469). IEEE</ul><p><br /></p><h1 id="footnote">footnote</h1><hr /><div class="footnotes" role="doc-endnotes"><ol><li id="fn:1"><p>고유값 분해(EVD, eigen value decomposition) 정방 행렬을 자신의 고유벡터로 이루어진 행렬과 고유값으로 이루어진 대각행렬로 대각화 분해하는 기법입니다. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:2"><p>고유 벡터(eigen vector)란 행렬에 대해 크기(scale)은 변하지만 방향은 변하지 않는 영벡터가 아닌 벡터를 말합니다. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:3"><p>열벡터끼리, 행벡터끼리 정규 직교(orthonormal) 하는 정방 행렬을 뜻합니다. 정의에 의해서 \(\boldsymbol{A}\boldsymbol{A}^T = \boldsymbol{I}\)의 성질을 가집니다. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p></ol></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/math/'>Math</a>, <a href='/categories/linear-algebra/'>Linear algebra</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/svd/" class="post-tag no-text-decoration" >svd</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=특이값 분해(Singular Value Decompostion) - 생각과 고민.&url=https://gguguk.github.io/posts/SVD/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=특이값 분해(Singular Value Decompostion) - 생각과 고민.&u=https://gguguk.github.io/posts/SVD/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=특이값 분해(Singular Value Decompostion) - 생각과 고민.&url=https://gguguk.github.io/posts/SVD/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/tsne/">T-SNE 이해하기</a><li><a href="/posts/how_to_work_python/">CS50 - 파이썬이 소스 코드를 실행하는 과정과 원리</a><li><a href="/posts/OIDC/">IRSA의 원리를 파헤쳐보자 4 - OIDC</a><li><a href="/posts/OAuth/">IRSA의 원리를 파헤쳐보자 3 - OAuth2.0</a><li><a href="/posts/admission_webhook/">IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/eigenvalue_eigenvector/"><div class="card-body"> <span class="timeago small" >Jan 5, 2021<i class="unloaded">2021-01-05T22:20:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>고유값(eigen value)과 고유벡터(eigen vector)</h3><div class="text-muted small"><p> 방향은 변하지 않고 크기만 변하는 벡터를 찾아라! 두줄 요약 !! 선형 변환을 했을 때 크기는 변하나 방향은 변하지 않는 벡터를 고유벡터라고 하고 변하는 크기는 고유값이라 함 행렬 분해 기법(EVD, SVD)과 PCA 등 여러 응용 사례의 가장 기초가 되는 개념 선형대수학 개념 중 고유값(ei...</p></div></div></a></div><div class="card"> <a href="/posts/PCA/"><div class="card-body"> <span class="timeago small" >Jan 11, 2021<i class="unloaded">2021-01-11T11:28:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PCA(주성분 분석)</h3><div class="text-muted small"><p> 원래 데이터들을 어느 벡터에 사영시켜야 데이터의 구조를 최대한 보존할 수 있을까? 3줄 요약 PCA는 데이터의 기존 구조를 최대한 유지하고자 하는 목적을 가진 변수 추출 또는 차원 축소 기법임 데이터의 기존 구조를 최대한 유지 하기 위해서는 사영(projection) 하였을 때 분산이 최대가 되는 방향의 벡터를 찾아야 함 데이터...</p></div></div></a></div><div class="card"> <a href="/posts/eigenvalue_decomposition/"><div class="card-body"> <span class="timeago small" >Jan 26, 2021<i class="unloaded">2021-01-26T22:18:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>고유값 분해(Eigenvalue Decompostion)</h3><div class="text-muted small"><p> 정방행렬을 고유벡터와 고유값의 행렬로 분해할 수 있다?! (Eigenvalue decomposition, OREILLY) 2줄 요약 고유값 분해는 \(n \times n\) 정방 행렬을 고유벡터로 이루어진 행렬과 고유값으로 이루어진 행렬로 대각화 하는 방법 행렬 거듭제곱, SVD 등에서 활용 됨 \(n \times n\)...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/custom_tensorflow_2/" class="btn btn-outline-primary" prompt="Older"><p>tf.keras 커스텀 하기</p></a> <a href="/posts/ALS/" class="btn btn-outline-primary" prompt="Newer"><p>'Collaborative Filtering for Implicit Feedback Datasets(ALS)' 논문 리뷰</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/gguguk">Gukwon Koo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/retrospective/">retrospective</a> <a class="post-tag" href="/tags/k8s/">k8s</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/nlp/">nlp</a> <a class="post-tag" href="/tags/statistics/">statistics</a> <a class="post-tag" href="/tags/irsa/">irsa</a> <a class="post-tag" href="/tags/ml/">ml</a> <a class="post-tag" href="/tags/mlops/">mlops</a> <a class="post-tag" href="/tags/paper/">paper</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://gguguk.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-8EWVG7CHCY"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-8EWVG7CHCY'); }); </script>

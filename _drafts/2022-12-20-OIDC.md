---
title: IRSA의 원리를 파헤쳐보자 4 - OIDC
author: Gukwon Koo
categories: [MLOps, Kubernetes]
tags: [kubernetes, k8s, oauth2.0, oidc, irsa]
pin: false
math: true
comments: true
date: 2022-12-20 21:00:00 +0900
---

지난 글에서는 OAuth2.0를 살펴보았습니다. OAuth2.0을 이해해야 본 글에서 설명할 OIDC를 이해할 수 있습니다. OIDC는 인증(authentication)을 위한 프로토콜입니다. 

IRSA의 원리를 파헤쳐보자 시리즈

1. [IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook](https://gguguk.github.io/posts/admission_webhook/)
2. [IRSA의 원리를 파헤쳐보자 2 - K8S Sevice Account와 Service Account Token Volume Projection](https://gguguk.github.io/posts/service_account_volume_projection/)
3. [IRSA의 원리를 파헤쳐보자 3 - OAuth2.0](https://gguguk.github.io/posts/OAuth/)
4. <u>IRSA의 원리를 파헤쳐보자 4 - OIDC</u>
5. IRSA의 원리를 파헤쳐보자 5 - K8S Sevice Account와 Service Account Token Volume Projection

<br>

# OIDC(OpenID Connect)

### OIDC란?

**OIDC(OpenID Connect)란 <u>OAuth 위에서</u> 동작하는 사용하는 인증(authentication)을 위한 프로토콜**입니다. 앞서 우리는 위에서 OAuth2.0에 대해서 배웠습니다. 인가를 담당하는 표준화된 프로토콜이라고 했죠. 그리고 인가를 하기 위해서 필연적으로 인증 과정이 수반되었습니다(구글 로그인, 페이스북 로그인 등) 이러한 사실 때문에 많은 사람들이 OAuth를 인가와 인증 두 가지 목적을 모두 담당하는 프로토콜이라고 오해하고 있습니다.(저도 포함입니다... 🙋‍♀️)

<br>

### OIDC와 OAuth를 구분하자

![](/assets/img/post_img/OIDC_metaphor.png)_사탕의 맛을 내기 위한 재료들과 사탕이 있습니다. 각각 인가와 인증으로 비유할 수 있습니다._

그러나 이는 엄청난 오해입니다. [비유를 들어서](https://oauth.net/articles/authentication/#:~:text=Authentication%20vs.%20Authorization%3A%20a%20metaphor) 쉽게 설명해보겠습니다(이해를 돕기 위한 비약이 있을 수 있습니다). 사탕의 맛을 내기 위한 재료들이 있습니다. 오렌지, 딸기, 초콜릿 등이 있습니다. 이런 재료들은 그 자체로도 충분히 우리의 먹거리가 되어줍니다. 그리고 사탕도 많은 종류가 있습니다. 오렌지 맛 사탕, 딸기 맛 사탕, 초콜릿 맛 사탕을 예시로 들 수 있습니다. 여기서 중요한 점은 초콜릿과 초콜릿 맛 사탕은 서로 깊은 연관이 있지만, 결국엔 서로 다르다는 것입니다.

이 비유에서 사탕의 맛을 내기 위한 재료들은 인가(authorization)를 구현하기 위한 여러가지 기술 또는 프로토콜이라고 할 수 있습니다. 그 중 가장 대중적으로 쓰이는 프로토콜이 바로 초콜릿, OAuth 2.0입니다. 그리고 초콜릿은 그 자체로 간식으로 먹는 것처럼 OAuth 2.0도 인가의 기능을 그 자체로 담당할 수 있습니다. 한편 사탕은 인증(authentication)을 구현하기 위한 기술 또는 프로토콜입니다. 특히 OIDC는 OAuth2.0에 기반을 둔 대표적인 프로토콜인데요, 일명 초콜릿 맛 사탕이라고 할 수 있겠습니다.

이처럼 OAuth(초콜릿)와 OIDC(초콜릿 맛 사탕)는 뗄려야 뗄 수 없는 관계입니다. 그러나 이 둘은 서로 엄연히 다른 목적을 가지고 있으며, OAuth와 OIDC를 혼동하는 것은 [OAuth 공식 문서](https://oauth.net/articles/authentication/)에서도 지적하고 있는 매우 중대한 오류입니다(그 이유에 대해서는 부록에 번역 및 작성해 두었습니다). OAuth는 인가를 위한 프로토콜인데, 특정 범위(scope)의 권한을 인가하기 위해서는 어쩔 수 없이 인증의 과정을 거치기는 합니다. 그러나 OAuth 흐름에서 발생하는 인증은 OAuth 프로토콜의 본래의 목적이 아니라 하나의 수단에 불과합니다. 한편 OIDC는 OAuth 위에서 동작하는 인증 프로토콜입니다. OAuth가 인가를 위해 어쩔 수 없이 인증 과정을 거치는데, 이 과정에서 OIDC는 인증을 위해 사용자의 신원을 식별하는데 활용 되는 `id_token`을 추가적으로 발급합니다(이때 OAuth는 access_token`을 발급합니다).

<br>

# OIDC 주체

OIDC는 Auth2.0 위에서 동작하는 프로토콜이지만, OIDC에 참여하는 주체들의 명칭은 Auth2.0과 조금 다릅니다.

- OpenID provider(IdP): ID token을 발급하는 인가 서버(authorization server)입니다. OAuth2.0에서의 인가 서버에 해당합니다.

- End user: 인증하는 주체입니다. OAuth2.0에서의 리소스 소유자(Resource owner)에 해당합니다.

- Relying party: OpenID provider에 id token을 요청하는 주체입니다. OAuth2.0에서의 클라이언트에 해당합니다.

  



#OIDC에서 id token을 발급 받는 과정

 다이어그램 그리기





### id_token

따라서 일반적으로는 OIDC 등을 활용하여 사용자의 정보를 담고 있는 id token을 따로 발급 하여 인증을 사용합니다. 이처럼 access token와 id token의 역할을 분리하면 OAuth 프로토콜의 원칙을 지키면서 인증 과정까지 함께 수행할 수 있는 장점이 있습니다. OIDC 프로토콜의 최종 결과로서 클라이언트는 `id_token`을 발급 받습니다. `id_token`은 JWT(Json Web Token) 형태이며, `Header`, `Payload`, `Signature`라는 총 3개의 파트로 구분 되어 있습니다.

<br>

`Header`에는 토큰 타입과 어떤 해시 암호화 알고리즘을 사용하는지 명시되어 있습니다.

```json
{
  "alg": "HS256",  // 해시 알고리즘 (HMAC, SHA256, RSA)
  "typ": "JWT" // 토큰 유형
}

```

<br>
`Payload`는 JWT의 핵심 내용이 명시 되어 있는 부분으로 여러 종류의 claim[^1]으로 구성되어 있습니다.

```json
{
  "iss": "https://accounts.google.com",
  "azp": "1234987819200.apps.googleusercontent.com",
  "aud": "1234987819200.apps.googleusercontent.com",
  "sub": "10769150350006150715113082367",
  "at_hash": "HK6E_P6Dh8Y93mRNtsDB1Q",
  "hd": "example.com",
  "email": "jsmith@example.com",
  "email_verified": "true",
  "iat": 1353601026,
  "exp": 1353604926,
  "nonce": "0394852-3190485-2490358"
}
```

특히 중요한 claim을 다음과 같습니다.

- `iss`(issuer): `id_token`을 발급한 주체(e.g., google, facebook, oidc provider)
- `aud`(audience): `id_token`을 활용하는 주체(e.g., 클라이언트, aws.sts)
- `sub`(subject): 리소스 오너(resource owner), 엔드 유저(end-user) (e.g., 사용자, 쿠버네티스 pod)
- `exp`: `id_token` 만료 시점
- `iat`: `id_token` 발급 시점

<br>

마지막으로 Signature는 id_token의 유효성을 검사 하기 위한 암호화된 문자열로 이루어져 있습니다. 해당 문자열은 id_token 발급자의 비밀키로 암호화 되어 있으므로, 발급자의 공개키로 복호화가 가능합니다(?).

<br>

### access token vs id token

|             | access token                                                 | id token                                                     |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| audience    | Access tokens are meant to be read by the resource server(Access tokens must not be read or interpreted by the OAuth client. The OAuth client is not the intended audience of the token). | ID tokens are meant to be read by the OAuth client           |
| information | Access tokens do not convey user identity or any other information about the user to the OAuth client. | An ID token contains information about what happened when a user authenticated.  The ID token may also contain information about the user such as their name or email address, although that is not a requirement of an ID token. |
| usage       | Access tokens should *only* be used to make requests to the resource server. | [ID tokens](https://oauth.net/id-tokens-vs-access-tokens/) must *not* be used to make requests to the resource server. |
| form        | [can be JWTs](https://oauth.net/2/jwt-access-tokens/) but may also be a random string | [JWTs](https://oauth.net/2/jwt/)                             |





<br>

# IRSA(IAM Role for Service Account) 프로세스

![](/assets/img/post_img/irsa_architecture.png)_IRSA High Level Architecture_

IRSA(IAM Role for Service Account)는 [이전 글]()에서 예시로 든 Pod identity webhook을 활용하여 Service Account Token Volume Projection 기능 구현하고, 이를 쿠버네티스 파드 별로 임시 자격 증명을 언급하고 AWS 리소스들에 엑세스 가능 하도록 하는 일종의 프로토콜입니다.

<br>

# 부록

## access_token을 유저 인증에 사용하면 안될까?

여기까지 오셨으면 OIDC와 OAuth와의 미묘한 차이를 이해하셨 것이라 생각합니다. 그런데 이렇게 생각해볼 수 있지 않을까요? OAuth는 어쨌든 인증 과정을 거쳐서 access_token을 발급해주었으니까 access_token을 인증 과정에 사용해도 되지 않을까요? 결론부터 말하면 이는 틀린 생각입니다. [oauth.net](https://oauth.net/articles/authentication/)에서는 OAuth로 인증을 하는 것의 위험성(*Common pitfalls for authentication using OAuth*)에 대해서 언급합니다.



### access token에는 유저를 식별할 수 있는 정보가 없습니다

access token을 발급 받는 과정에 사용자 인증이 선행되기 때문에 OAuth 자체가 인증도 담당하고 있다고 생각할 수 있습니다. 그러나 access token은 근본적으로 client를 위한 개념이 아닙니다. 다시말해, access token의 audience(토근 발급 대상, 토근의 최종 사용 주체)는 client가 아니라 resource server(protected resource)입니다. client 입장에서 access token은 아무런 의미 없는 string에 불과합니다(*the token is designed to be opaque to the client*). 극단적으로 말하면, access token의 포맷이 바뀌었어도 authorization server와 resource server간의 로직만 이상없다면 client 입장에서는 신경 쓸 일이 전혀 없습니다. 그저 resource server로 access token을 전달하기만 하면 되니까요. 또한 access token에는 사용자와 관련된 데이터(`user_id`나 `email` 등)는 전혀 없으므로 클라이언트가 사용자를 식별할 수 있는 방법은 없습니다. client가 access token으로 사용자를 식별한다는 행위는 애초에 불가능한 행위라는 것입니다.



### 유저의 인증 없이도 access token이 발급될 수 있습니다.

OAuth 과정에서 유저의 로그인을 통해 인증을 수행하고 최종적으로 access token을 발급 받을 수 있습니다. 그러나 이것이 access token을 발급 받을 수 있는 유일한 방법은 아닙니다. refresh token을 활용하여 유저의 인증 없이도 access token을 새로 발급 받을 수도 있습니다. 즉 access token을 발급 받았다는 사실 자체가 유저가 인증되었음을 완벽하게 보장할 수 없다는 뜻입니다.



### 인증 서버가 아닌 제 3자가 access token을 주입할 수도 있습니다.

만일 acces token이 URL 파라미터로 전달되는 implicit flow를 따르고, client가 access token의 유효성을 점검할 수 있는 메커니즘이 없다면 access token의 진위 여부를 판별하기 어렵습니다. 따라서 access token만으로 유저가 진짜로 인증했는지 여부를 판별하기 어렵습니다.



### access token을 발급 해준 client인지 여부를 검증하는 메커니즘이 없습니다.

예를 들어, A라는 client가 정상적인 방법을 통해 access token을 발급 받은 후에 B라는 client가 해당 access token을 그대로 사용한다면, 일반적인 OAuth API들은 client를 검증하는 메커니즘이 없으므로 정상적으로 resource server와 통신이 일어날 것입니다. B라는 client가 A라는 client가 발급 받은 access token을 사용함에 있어서 유저의 인증은 개입되지 않았다는 점에서 access token으로 유저 인증을 하기에는 부족한 면이 있습니다.



### access token에 대한 표준 형식이 없습니다.

OAuth 상에서 유저 인증 과정을 처리하려는 시도에 있어서 가장 큰 문제점은 access token의 [표준 형식이 정해져있지 않다는 것](https://www.rfc-editor.org/rfc/rfc6749#section-1.4)입니다(*access tokens can have different formats, structures, and methods of utilization*) 예를 들어서 google에서는 유저의 아이디를 user_id 필드에 넘겨주는데, 페이스북에서는 subject 필드에 넘겨줄 수도 있습니다. 두 필드는 의미상으로는 동일하지만, 이를 처리하기 위해서는 서로 다른 방식으로 처리하는 코드를 짜야하기 때문에 번거롭습니다.

<br>

# 참고자료

- [JWT (Json Web Token) Audience "aud" versus Client_Id - What's the difference?](https://stackoverflow.com/questions/28418360/jwt-json-web-token-audience-aud-versus-client-id-whats-the-difference)
- [OAuth 그리고 OpenID Connect](https://6991httam.medium.com/oauth%EB%9E%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-openid-8c46a65616e6)
- [ID Tokens vs Access Tokens](https://oauth.net/id-tokens-vs-access-tokens/)
- [ID Token and Access Token: What's the Difference?](https://auth0.com/blog/id-token-access-token-what-is-the-difference/)
- [JWT(JSON Web Token)을 이용한 API 인증 - #1 개념 소개](https://bcho.tistory.com/999)
- [OIDC (OpenID Connect)](https://ssup2.github.io/theory_analysis/OIDC/)
- [인증과 인가 (권한 부여) 비교 – 특징 및 차이점](https://gguguk.github.io/posts/oidc/)
- [OpenID(OIDC) 개념과 동작원리](https://hudi.blog/open-id/)
- [호다닥 공부해보는 SSO와 친구들 (SAML, OAuth, OIDC)](https://gruuuuu.github.io/security/ssofriends/)
- [OAuth 2.0 and OpenID Connect Overview](https://developer.okta.com/docs/concepts/oauth-openid/)



[^1]: JWT에서 claim이란 프로퍼티나 속성을 말합니다. `"iss": "https://abc.com"` 를 하나의 claim이라고 할 수 있으며, `iss`를 claim 이름, `https://abc.com`을 claim 값이라고 합니다.
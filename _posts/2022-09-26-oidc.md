---
title: IRSA의 원리를 파헤쳐보자 2 - OAuth2.0과 OIDC(OpenID Connect)
author: Gukwon Koo
categories: [MLOps, Kubernetes]
tags: [kubernetes, k8s, oauth2.0, oidc, irsa]
pin: false
math: true
comments: true
date: 2022-09-26 22:12:00 +0900
---

IRSA의 원리를 파헤쳐보자 시리즈의 두번째 글입니다. 지난 시간에는 IRSA를 가능하게 하는 가장 근본적인 컴포넌트인 [Admission Webhook](https://gguguk.github.io/posts/admission_webhook/)에 대해서 살펴 보았습니다. EKS 클러스터를 생성하면 pod identity webhook이라는 admission webhook이 함께 설치됩니다. pod identity webhook은 `kube-apiserver`에 파드 생성 요청이 도착할 경우 해당 파드에 적용된 service account에 iam role arn이 설정되어 있는 경우 요청 내용을 IRSA를 가능하도록 변경하는 mutating webhook이었습니다.

이후 시리즈 글에서 더 자세히 살펴 보겠지만 pod identity webhook의 mutating 결과로 파드에 어떤 token이 주어지게 됩니다. 해당 token은 파드가 AWS의 특정 리소스와 통신하기 위한 임시 자격 증명을 발급 받는데에 사용됩니다. 이러한 일련의 과정은 OIDC(OpenID Connect)라는 프로토콜에 따라 진행됩니다. 최종적으로 pod에 주입되는 토큰은 id token이라고 할 수 있습니다. 그리고 OIDC는 OAuth2.0 위에서 작동합니다. 따라서 OAuth2.0과 OIDC는 함께 살펴 보아야 하는 친구들인 것이죠! 본 글에서는 IRSA를 이해하기 위한 배경지식으로 OAuth2.0과 OIDC에 대해서 살펴보겠습니다.

IRSA의 원리를 파헤쳐보자 시리즈

1. [IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook](https://gguguk.github.io/posts/admission_webhook/)
2. IRSA의 원리를 파헤쳐보자 2 - OAuth2.0과 OIDC(OpenID Connect)
3. IRSA의 원리를 파헤쳐보자 3 - K8S Sevice Account와 Service Account Token Volume Projection

<br>

# 인증(authentication)과 인가(authorization)

앞으로의 내용에 인증(authentication)과 인가(authorization)이라는 단어가 계속해서 등장할 것입니다. 헷갈릴 수 있는 내용이기 때문에 먼저 정리하고 출발 하겠습니다. 인증과 인가... 한국어로 보면 큰 차이가 없어 보이는 단어입니다. 일상적인 용어에서는 쓰임새가 크게 차이가 나지 않는 단어죠. 하지만 컴퓨터 세상에서는 매우 큰 차이가 있습니다. 먼저 인증이란 사용자의 신원(identity)를 확인하는 일을 말합니다. 그리고 인가는 특정 유저가 수행할 권한의 범위(scope)를 허가해 주는 일을 말합니다.

인증을 담당하는 

<br>

#  OAuth2.0

OAuth2.0(이하 OAuth)란 인가(authorization)를 위한 프로토콜입니다.

- 리소스 오너(resource owner)
- 리소스 서버(resource sever)
- 인가 서버(authorization server)

### access token



<br>

# OIDC(OpenID Connect)

### OIDC란?

**OIDC(OpenID Connect)란 <u>OAuth 위에서</u> 동작하는 사용하는 인증(authentication)을 위한 프로토콜**입니다. 앞서 우리는 위에서 OAuth2.0에 대해서 배웠습니다. 인가를 담당하는 표준화된 프로토콜이라고 했죠. 그리고 인가를 하기 위해서 필연적으로 인증 과정이 수반되었습니다(구글 로그인, 페이스북 로그인 등) 이러한 사실 때문에 많은 사람들이 OAuth를 인가와 인증 두 가지 목적을 모두 담당하는 프로토콜이라고 오해하고 있습니다.(여기에 저도 포함입니다... 🙋‍♀️)

<br>

### OIDC와 OAuth를 구분하자

그러나 이는 엄청난 오해입니다. OAuth와 인증은 초콜릿과 퍼지(일종의 캔디)로 비유할 수 있습니다. 초콜릿은 다른 여러 식재료의 재료가 되면서도 그 자체가 식재료가 될 수 있습니다. 그리고 퍼지는 초콜릿을 조합하여 만들 수도 있지만 다른 식재료를 조합하여 만들 수도 있습니다(코코넛 감자 퍼지). 따라서 우리는 초콜릿을 퍼지와 동일한 것으로 취급하지는 않습니다. 또한 초콜릿을 초콜릿 퍼지와 동일하게 취급하는 것도 틀린 표현입니다. 초콜릿과 퍼지의 비유에서 **초콜릿은 OAuth**입니다. OAuth는 다른 기술을 위한 베이스가 되기도 하지만, 단독으로 인가의 기능을 수행할 수도 있습니다. **퍼지는 인증**입니다. 인증을 위해서는 다양한 기술이 활용됩니다. OAuth도 인증을 구현하기 위한 바탕이 되는 기술 중 하나일뿐입니다. **특히 OAuth 프로토콜 위에서 인증을 구현한 프로토콜이 바로 OIDC(OpenID Connect)**입니다.

이처럼 OAuth와 OIDC는 뗄려야 뗄 수 없는 관계입니다. 그러나 OAuth와 OIDC를 혼동하는 것은 [OAuth 공식 문서](https://oauth.net/articles/authentication/)에서도 지적하고 있는 매우 중대한 오류입니다. 정리하자면, OAuth는 인가를 위한 프로토콜인데, 특정 범위(scope)의 권한을 인가하기 위해서는 어쩔 수 없이 인증의 과정을 거치기는 합니다. 그러나 OAuth 흐름에서 발생하는 인증은 본래의 목적이 아닙니다. 하나의 수단에 불과합니다. 한편 OIDC는 OAuth 위에서 동작하는 인증 프로토콜입니다. OAuth가 인가를 위해 어쩔 수 없이 인증 과정을 거치는데, 이를 활용하여 사용자의 신원을 식별할 수 있는 `id_token`을 발급합니다(이때 일반적으로 `access_token`도 같이 발급됩니다).

<br>

### access_token을 인증에 사용하면 안될까?

여기까지 오셨으면 OIDC와 OAuth와의 미묘한 차이를 이해하셨 것이라 생각합니다. 그러나 이렇게 생각해볼 수 있지 않을까요? OAuth는 어쨌든 인증 과정을 거쳐서 access_token을 발급해주었으니까 access_token을 인증 과정에 사용해도 되지 않을까요? 결론부터 말하면 이는 틀린 생각입니다. [oauth.net](https://oauth.net/articles/authentication/)에서는 OAuth로 인증을 하는 것의 위험성(*Common pitfalls for authentication using OAuth*)에 대해서 언급합니다.

#### Access tokens as proof of authentication

access token을 발급 받는 과정에 사용자 인증이 선행되기 때문에 OAuth 자체가 사용자 인증도 담당하고 있다고 생각할 수 있습니다. 그러나 access token에는 사용자의 정보와 관련된 데이터가 아무 것도 없기 때문에 클라이언트는 사용자를 전혀 식별할 수 없습니다. 인증 과정은 유저와 인가 서버 사이에서만 발생한다는 사실을 생각 해보면 당연한 이야기입니다. 따라서 일반적으로는 OIDC 등을 활용하여 사용자의 정보를 담고 있는 id token을 따로 발급 하여 인증을 사용합니다. 이처럼 access token와 id token의 역할을 분리하면 OAuth 프로토콜의 원칙을 지키면서 인증 과정까지 함께 수행할 수 있는 장점이 있습니다.

#### Access of a protected API as proof of authentication

#### Injection of access tokens

#### Lack of audience restriction

#### Injection of invalid user information

#### Different protocols for every potential identity provider

<br>



### id_token은 어떻게 생겼나?

OIDC 프로토콜의 최종 결과로서 클라이언트는 `id_token`을 발급 받습니다. id_token은 JWT(Json Web Token) 형태이며, 신원 확인을 위한 여러가지 정보를 담고 있습니다.

```json
{
  "iss": "https://accounts.google.com",
  "azp": "1234987819200.apps.googleusercontent.com",
  "aud": "1234987819200.apps.googleusercontent.com",
  "sub": "10769150350006150715113082367",
  "at_hash": "HK6E_P6Dh8Y93mRNtsDB1Q",
  "hd": "example.com",
  "email": "jsmith@example.com",
  "email_verified": "true",
  "iat": 1353601026,
  "exp": 1353604926,
  "nonce": "0394852-3190485-2490358"
}
```

다양한 필드가 있는데, 중요하게 살펴보아야할 필드는 다음과 같습니다.

- `iss`(issuer): `id_token`을 발급한 주체(e.g., google, facebook, oidc provider)
- `aud`(audience): `id_token`을 활용하는 주체(e.g., 클라이언트, sts)
- `sub`(subject): 리소스 오너(resource owner), 엔드 유저(end-user) (e.g., 사용자, 쿠버네티스 pod)
- `exp`: `id_token` 만료 시점
- `iat`: `id_token` 발급 시점

<br>

# 마무리

정리 내용 작성

<br>

# 참고자료

- [AWS EKS의 RBAC, IRSA 딥다이브](https://surgach.tistory.com/119)
- [https://developers.google.com/identity/protocols/oauth2/openid-connect](https://developers.google.com/identity/protocols/oauth2/openid-connect)
- [Naver D2 - OAuth와 춤을](https://d2.naver.com/helloworld/24942)
- [JWT (Json Web Token) Audience "aud" versus Client_Id - What's the difference?](https://stackoverflow.com/questions/28418360/jwt-json-web-token-audience-aud-versus-client-id-whats-the-difference)
- [OAuth 그리고 OpenID Connect](https://6991httam.medium.com/oauth%EB%9E%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-openid-8c46a65616e6)
- [ID Tokens vs Access Tokens](https://oauth.net/id-tokens-vs-access-tokens/)
- [ID Token and Access Token: What's the Difference?](https://auth0.com/blog/id-token-access-token-what-is-the-difference/)
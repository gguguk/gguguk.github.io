---
title: IRSA의 원리를 파헤쳐보자 2 - OAuth2.0과 OIDC(OpenID Connect)
author: Gukwon Koo
categories: [MLOps, Kubernetes]
tags: [kubernetes, k8s, oauth2.0, oidc, irsa]
pin: false
math: true
comments: true
date: 2022-09-26 22:12:00 +0900
---

IRSA의 원리를 파헤쳐보자 시리즈의 두번째 글입니다. 지난 시간에는 IRSA를 가능하게 하는 가장 근본적인 컴포넌트인 [Admission Webhook](https://gguguk.github.io/posts/admission_webhook/)에 대해서 살펴 보았습니다. EKS 클러스터를 생성하면 pod identity webhook이라는 admission webhook이 함께 설치됩니다. pod identity webhook은 `kube-apiserver`에 파드 생성 요청이 도착할 경우 해당 파드에 적용된 service account에 iam role arn이 설정되어 있는 경우 요청 내용을 IRSA를 가능하도록 변경하는 mutating webhook이었습니다.

이후 시리즈 글에서 더 자세히 살펴 보겠지만 pod identity webhook의 mutating 결과로 파드에 어떤 token이 주어지게 됩니다. 해당 token은 파드가 AWS의 특정 리소스와 통신하기 위한 임시 자격 증명을 발급 받는데에 사용됩니다. 이러한 일련의 과정은 OIDC(OpenID Connect)라는 프로토콜에 따라 진행됩니다. 최종적으로 pod에 주입되는 토큰은 id token이라고 할 수 있습니다. 그리고 OIDC는 OAuth2.0 위에서 작동합니다. 따라서 OAuth2.0과 OIDC는 함께 살펴 보아야 하는 친구들인 것이죠! 본 글에서는 IRSA를 이해하기 위한 배경지식으로 OAuth2.0과 OIDC에 대해서 살펴보겠습니다.

IRSA의 원리를 파헤쳐보자 시리즈

1. [IRSA의 원리를 파헤쳐보자 1 - K8S Admission Webhook](https://gguguk.github.io/posts/admission_webhook/)
2. IRSA의 원리를 파헤쳐보자 2 - OAuth2.0과 OIDC(OpenID Connect)
3. IRSA의 원리를 파헤쳐보자 3 - K8S Sevice Account와 Service Account Token Volume Projection

<br>

# 인증(authentication)과 인가(authorization)

![authentication_and_authorization](https://www.okta.com/sites/default/files/styles/1640w_scaled/public/media/image/2020-10/Authentication_vs_Authorization.png?itok=uBFRCfww)_인증과 인가의 차이(출처: [okta](https://www.okta.com/kr/identity-101/authentication-vs-authorization/))_

앞으로의 내용에 인증(authentication)과 인가(authorization)이라는 단어가 계속해서 등장할 것입니다. 인증과 인가는 한국어로 보면 큰 차이가 없어 보이는 단어인데요, 보완의 맥락에서는 엄연히 다른 개념입니다. 먼저 인증이란 사용자의 신원(identity)를 확인 및 검증 하는 행위입니다. 인증의 대표적인 예로는 아이디와 비밀번호를 통한 로그인이 있습니다. 한편 인가는 사용자에게 특정 리소스나 기능에 접근할 수 있는 권한 또는 권한의 범위(scope)를 부여하는 행위를 말합니다. 우리가 네이버에 로그인(인증)을 했다고 하더라도 다른 사람의 데이터에 접근할 수 있는 권한은 없습니다. 다시 말해 타인의 데이터에 접근하는 인가는 받지 못한 것입니다.

이어지는 글에서 더 자세히 설명하겠지만 인증과 인가는 각각 OIDC, OAuth2.0와 관련이 깊습니다. OIDC는 인증을 담당하는 프로토콜이며, OAuth2.0은 인가를 담당하는 프로토콜입니다. 그렇다고 해서 OIDC와 OAuth2.0이 아예 별개의 개념이진 않습니다. 오히려 서로는 매우 깊은 관련이 있습니다.

<br>

#  OAuth2.0

OAuth2.0(이하 OAuth)란 인가(authorization)를 위한 프로토콜입니다.

Oauth2.0의 내용은 비교적 간단하게 작성하자... OIDC가 IRSA를 이해하는데 핵심이니까... OIDC 부분에 좀 힘쓰자.

- 리소스 오너(resource owner)
- 리소스 서버(resource sever)
- 인가 서버(authorization server)

### access token



<br>

# OIDC(OpenID Connect)

### OIDC란?

**OIDC(OpenID Connect)란 <u>OAuth 위에서</u> 동작하는 사용하는 인증(authentication)을 위한 프로토콜**입니다. 앞서 우리는 위에서 OAuth2.0에 대해서 배웠습니다. 인가를 담당하는 표준화된 프로토콜이라고 했죠. 그리고 인가를 하기 위해서 필연적으로 인증 과정이 수반되었습니다(구글 로그인, 페이스북 로그인 등) 이러한 사실 때문에 많은 사람들이 OAuth를 인가와 인증 두 가지 목적을 모두 담당하는 프로토콜이라고 오해하고 있습니다.(여기에 저도 포함입니다... 🙋‍♀️)

<br>

### OIDC와 OAuth를 구분하자

그러나 이는 엄청난 오해입니다. OAuth와 인증은 초콜릿과 퍼지(일종의 캔디)로 비유할 수 있습니다. 초콜릿은 다른 여러 식재료의 재료가 되면서도 그 자체가 식재료가 될 수 있습니다. 그리고 퍼지는 초콜릿을 조합하여 만들 수도 있지만 다른 식재료를 조합하여 만들 수도 있습니다(코코넛 감자 퍼지). 따라서 우리는 초콜릿을 퍼지와 동일한 것으로 취급하지는 않습니다. 또한 초콜릿을 초콜릿 퍼지와 동일하게 취급하는 것도 틀린 표현입니다. 초콜릿과 퍼지의 비유에서 **초콜릿은 OAuth**입니다. OAuth는 다른 기술을 위한 베이스가 되기도 하지만, 단독으로 인가의 기능을 수행할 수도 있습니다. **퍼지는 인증**입니다. 인증을 위해서는 다양한 기술이 활용됩니다. OAuth도 인증을 구현하기 위한 바탕이 되는 기술 중 하나일뿐입니다. **특히 OAuth 프로토콜 위에서 인증을 구현한 프로토콜이 바로 OIDC(OpenID Connect)**입니다.

이처럼 OAuth와 OIDC는 뗄려야 뗄 수 없는 관계입니다. 그러나 OAuth와 OIDC를 혼동하는 것은 [OAuth 공식 문서](https://oauth.net/articles/authentication/)에서도 지적하고 있는 매우 중대한 오류입니다(그 이유에 대해서는 부록에 번역 및 작성해 두었습니다). 정리하자면, OAuth는 인가를 위한 프로토콜인데, 특정 범위(scope)의 권한을 인가하기 위해서는 어쩔 수 없이 인증의 과정을 거치기는 합니다. 그러나 OAuth 흐름에서 발생하는 인증은 본래의 목적이 아닙니다. 하나의 수단에 불과합니다. 한편 OIDC는 OAuth 위에서 동작하는 인증 프로토콜입니다. OAuth가 인가를 위해 어쩔 수 없이 인증 과정을 거치는데, 이를 활용하여 사용자의 신원을 식별할 수 있는 `id_token`을 발급합니다(이때 일반적으로 `access_token`도 같이 발급됩니다).

<br>

### id_token

따라서 일반적으로는 OIDC 등을 활용하여 사용자의 정보를 담고 있는 id token을 따로 발급 하여 인증을 사용합니다. 이처럼 access token와 id token의 역할을 분리하면 OAuth 프로토콜의 원칙을 지키면서 인증 과정까지 함께 수행할 수 있는 장점이 있습니다. OIDC 프로토콜의 최종 결과로서 클라이언트는 `id_token`을 발급 받습니다. `id_token`은 JWT(Json Web Token) 형태이며, `Header`, `Payload`, `Signature`라는 총 3개의 파트로 구분 되어 있습니다.

<br>

`Header`에는 토큰 타입과 어떤 해시 암호화 알고리즘을 사용하는지 명시되어 있습니다.

```json
{
  "alg": "HS256",  // 해시 알고리즘 (HMAC, SHA256, RSA)
  "typ": "JWT" // 토큰 유형
}

```

<br>
`Payload`는 JWT의 핵심 내용이 명시 되어 있는 부분으로 여러 종류의 claim[^1]으로 구성되어 있습니다.

```json
{
  "iss": "https://accounts.google.com",
  "azp": "1234987819200.apps.googleusercontent.com",
  "aud": "1234987819200.apps.googleusercontent.com",
  "sub": "10769150350006150715113082367",
  "at_hash": "HK6E_P6Dh8Y93mRNtsDB1Q",
  "hd": "example.com",
  "email": "jsmith@example.com",
  "email_verified": "true",
  "iat": 1353601026,
  "exp": 1353604926,
  "nonce": "0394852-3190485-2490358"
}
```

특히 중요한 claim을 다음과 같습니다.

- `iss`(issuer): `id_token`을 발급한 주체(e.g., google, facebook, oidc provider)
- `aud`(audience): `id_token`을 활용하는 주체(e.g., 클라이언트, aws.sts)
- `sub`(subject): 리소스 오너(resource owner), 엔드 유저(end-user) (e.g., 사용자, 쿠버네티스 pod)
- `exp`: `id_token` 만료 시점
- `iat`: `id_token` 발급 시점

<br>

마지막으로 Signature는 id_token의 유효성을 검사 하기 위한 암호화된 문자열로 이루어져 있습니다. 해당 문자열은 id_token 발급자의 비밀키로 암호화 되어 있으므로, 발급자의 공개키로 복호화가 가능합니다(?).

<br>

### OIDC에서 id token을 발급 받는 과정

 다이어그램 그리기

# 마무리

정리 내용 작성

<br>

# 부록

## access_token을 유저 인증에 사용하면 안될까?

여기까지 오셨으면 OIDC와 OAuth와의 미묘한 차이를 이해하셨 것이라 생각합니다. 그런데 이렇게 생각해볼 수 있지 않을까요? OAuth는 어쨌든 인증 과정을 거쳐서 access_token을 발급해주었으니까 access_token을 인증 과정에 사용해도 되지 않을까요? 결론부터 말하면 이는 틀린 생각입니다. [oauth.net](https://oauth.net/articles/authentication/)에서는 OAuth로 인증을 하는 것의 위험성(*Common pitfalls for authentication using OAuth*)에 대해서 언급합니다.



### access token에는 유저를 식별할 수 있는 정보가 없습니다

access token을 발급 받는 과정에 사용자 인증이 선행되기 때문에 OAuth 자체가 인증도 담당하고 있다고 생각할 수 있습니다. 그러나 access token은 근본적으로 client를 위한 개념이 아닙니다. 다시말해, access token의 audience(토근 발급 대상, 토근의 최종 사용 주체)는 client가 아니라 resource server(protected resource)입니다. client 입장에서 access token은 아무런 의미 없는 string에 불과합니다(*the token is designed to be opaque to the client*). 극단적으로 말하면, access token의 포맷이 바뀌었어도 authorization server와 resource server간의 로직만 이상없다면 client 입장에서는 신경 쓸 일이 전혀 없습니다. 그저 resource server로 access token을 전달하기만 하면 되니까요. 또한 access token에는 사용자와 관련된 데이터(`user_id`나 `email` 등)는 전혀 없으므로 클라이언트가 사용자를 식별할 수 있는 방법은 없습니다. client가 access token으로 사용자를 식별한다는 행위는 애초에 불가능한 행위라는 것입니다.



### 유저의 인증 없이도 access token이 발급될 수 있습니다.

OAuth 과정에서 유저의 로그인을 통해 인증을 수행하고 최종적으로 access token을 발급 받을 수 있습니다. 그러나 이것이 access token을 발급 받을 수 있는 유일한 방법은 아닙니다. refresh token을 활용하여 유저의 인증 없이도 access token을 새로 발급 받을 수도 있습니다. 즉 access token을 발급 받았다는 사실 자체가 유저가 인증되었음을 완벽하게 보장할 수 없다는 뜻입니다.



### 인증 서버가 아닌 제 3자가 access token을 주입할 수도 있습니다.

만일 acces token이 URL 파라미터로 전달되는 implicit flow를 따르고, client가 access token의 유효성을 점검할 수 있는 메커니즘이 없다면 access token의 진위 여부를 판별하기 어렵습니다. 따라서 access token만으로 유저가 진짜로 인증했는지 여부를 판별하기 어렵습니다.



### access token을 발급 해준 client인지 여부를 검증하는 메커니즘이 없습니다.

예를 들어, A라는 client가 정상적인 방법을 통해 access token을 발급 받은 후에 B라는 client가 해당 access token을 그대로 사용한다면, 일반적인 OAuth API들은 client를 검증하는 메커니즘이 없으므로 정상적으로 resource server와 통신이 일어날 것입니다. B라는 client가 A라는 client가 발급 받은 access token을 사용함에 있어서 유저의 인증은 개입되지 않았다는 점에서 access token으로 유저 인증을 하기에는 부족한 면이 있습니다.



### access token에 대한 표준 형식이 없습니다.

OAuth 상에서 유저 인증 과정을 처리하려는 시도에 있어서 가장 큰 문제점은 access token의 [표준 형식이 정해져있지 않다는 것](https://www.rfc-editor.org/rfc/rfc6749#section-1.4)입니다(*access tokens can have different formats, structures, and methods of utilization*) 예를 들어서 google에서는 유저의 아이디를 user_id 필드에 넘겨주는데, 페이스북에서는 subject 필드에 넘겨줄 수도 있습니다. 두 필드는 의미상으로는 동일하지만, 이를 처리하기 위해서는 서로 다른 방식으로 처리하는 코드를 짜야하기 때문에 번거롭습니다.

<br>

# 참고자료

- [AWS EKS의 RBAC, IRSA 딥다이브](https://surgach.tistory.com/119)
- [https://developers.google.com/identity/protocols/oauth2/openid-connect](https://developers.google.com/identity/protocols/oauth2/openid-connect)
- [Naver D2 - OAuth와 춤을](https://d2.naver.com/helloworld/24942)
- [JWT (Json Web Token) Audience "aud" versus Client_Id - What's the difference?](https://stackoverflow.com/questions/28418360/jwt-json-web-token-audience-aud-versus-client-id-whats-the-difference)
- [OAuth 그리고 OpenID Connect](https://6991httam.medium.com/oauth%EB%9E%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-openid-8c46a65616e6)
- [ID Tokens vs Access Tokens](https://oauth.net/id-tokens-vs-access-tokens/)
- [ID Token and Access Token: What's the Difference?](https://auth0.com/blog/id-token-access-token-what-is-the-difference/)
- [The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749)
- [JWT(JSON Web Token)을 이용한 API 인증 - #1 개념 소개](https://bcho.tistory.com/999)
- [OIDC (OpenID Connect)](https://ssup2.github.io/theory_analysis/OIDC/)
- [인증과 인가 (권한 부여) 비교 – 특징 및 차이점](https://gguguk.github.io/posts/oidc/)



[^1]: JWT에서 claim이란 프로퍼티나 속성을 말합니다. `"iss": "https://abc.com"` 를 하나의 claim이라고 할 수 있으며, `iss`를 claim 이름, `https://abc.com`을 claim 값이라고 합니다.